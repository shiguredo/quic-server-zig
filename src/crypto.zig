const std = @import("std");
const mem = std.mem;
const ArrayList = std.ArrayList;
const crypto = std.crypto;
const Aes128 = crypto.core.aes.Aes128;
const Aes256 = crypto.core.aes.Aes256;
const ChaCha20IETF = crypto.stream.chacha.ChaCha20IETF;
const Aes128Gcm = crypto.aead.aes_gcm.Aes128Gcm;
const Aes256Gcm = crypto.aead.aes_gcm.Aes256Gcm;
const ChaCha20Poly1305 = crypto.aead.chacha_poly.ChaCha20Poly1305;
const HmacSha256 = crypto.auth.hmac.sha2.HmacSha256;
const HkdfSha256 = crypto.kdf.hkdf.HkdfSha256;
const HmacSha384 = crypto.auth.hmac.sha2.HmacSha384;
const HkdfSha384 = crypto.kdf.hkdf.Hkdf(HmacSha384);
const VariableLengthVector = @import("./variable_length_vector.zig").VariableLengthVector;
const Bytes = @import("./bytes.zig").Bytes;
const utils = @import("../utils.zig");

//pub const Algorithm = enum {
//    AES128_GCM,
//    AES256_GCM,
//    ChaCha20_Poly1305,
//
//    const Self = @This();
//
//    pub fn key_length(self: Self) usize {
//        return switch (self) {
//            .AES128_GCM => Aes128Gcm.key_length,
//            .AES256_GCM => Aes256Gcm.key_length,
//            .ChaCha20_Poly1305 => ChaCha20Poly1305.key_length,
//        };
//    }
//
//    pub fn nonce_length(self: Self) usize {
//        return switch (self) {
//            .AES128_GCM => Aes128Gcm.nonce_length,
//            .AES256_GCM => Aes256Gcm.nonce_length,
//            .ChaCha20_Poly1305 => ChaCha20Poly1305.nonce_length,
//        };
//    }
//
//    pub fn tag_length(self: Self) usize {
//        return switch (self) {
//            .AES128_GCM => Aes128Gcm.tag_length,
//            .AES256_GCM => Aes256Gcm.tag_length,
//            .ChaCha20_Poly1305 => ChaCha20Poly1305.tag_length,
//        };
//    }
//
//    pub fn mac_length(self: Self) usize {
//        return switch (self) {
//            .AES128_GCM, .ChaCha20_Poly1305 => HmacSha256.mac_length,
//            .AES256_GCM => HmacSha384.mac_length,
//        };
//    }
//
//    /// Return the number of bytes used when deriving the header protection mask.
//    ///
//    /// https://www.rfc-editor.org/rfc/rfc9001#name-header-protection-sample
//    pub fn sample_length(self: Self) usize {
//        return switch (self) {
//            .AES128_GCM, .AES256_GCM, .ChaCha20_Poly1305 => 16,
//        };
//    }
//
//    /// Extract a master key from a salt and initial keying material, and write it into `out`.
//    /// Make sure that the length of `out` matches that of the underlying hash algorithm.
//    pub fn hkdfExtract(self: Self, out: []u8, salt: []const u8, initial_keying_material: []const u8) void {
//        std.debug.assert(out.len == self.mac_length);
//
//        switch (self) {
//            .AES128_GCM, .ChaCha20_Poly1305 => {
//                const k = HkdfSha256.extract(salt, initial_keying_material);
//                mem.copy(u8, out, &k);
//            },
//            .AES256_GCM => {
//                const k = HkdfSha384.extract(salt, initial_keying_material);
//                mem.copy(u8, out, &k);
//            },
//        }
//    }
//
//    /// Derive a subkey from a master key `key` and a subkey description `ctx`, and write it into `out`.
//    pub fn hkdfExpand(self: Self, out: []u8, ctx: []const u8, key: []const u8) void {
//        std.debug.assert(key.len == self.mac_length);
//
//        switch (self) {
//            .AES128_GCM, .ChaCha20_Poly1305 => {
//                const k: u8[self.mac_length()] = undefined;
//                mem.copy(u8, &k, key);
//                HkdfSha256.expand(out, ctx, k);
//            },
//            .AES256_GCM => {
//                const k: u8[self.mac_length()] = undefined;
//                mem.copy(u8, &k, key);
//                HkdfSha384.expand(out, ctx, k);
//            },
//        }
//    }
//
//    pub fn deriveMask(self: Self, header_protection_key: []const u8, sample: []const u8) [5]u8 {
//        switch (self) {
//            .AES128_GCM => {
//                const ctx = Aes128.initEnc(header_protection_key);
//            },
//        }
//    }
//};

pub fn Algorithm(comptime Aead: type, comptime Hmac: type, comptime Hkdf: type) type {
    _ = Hkdf;

    return struct {
        key: [Aead.key_length]u8,
        initialization_vector: [Aead.nonce_length]u8,
        header_protection_key: [Aead.key_length]u8,

        const Self = @This();

        pub fn fromSecret(secret: [Hmac.mac_length]u8) !Self {
            const key = try deriveAeadKey(Aead, Hmac, secret);
            const iv = try deriveInitializationVector(Aead, Hmac, secret);
            const hp = try deriveHeaderProtectionKey(Aead, secret);

            return Self{
                .key = key,
                .initialization_vector = iv,
                .header_protection_key = hp,
            };
        }

        /// Derive a header protection mask from a header protection key and sampled ciphertext.
        /// https://www.rfc-editor.org/rfc/rfc9001#name-header-protection
        fn deriveMask(self: Self, sample: *const [16]u8) [5]u8 {
            switch (self) {
                .AES128_GCM => {
                    // https://www.rfc-editor.org/rfc/rfc9001#name-aes-based-header-protection
                    const ctx = Aes128.initEnc(self.header_protection_key);
                    var encrypted: [16]u8 = undefined;
                    ctx.encrypt(&encrypted, sample);
                    return encrypted[0..5].*;
                },
                .AES128_GCM => {
                    // https://www.rfc-editor.org/rfc/rfc9001#name-aes-based-header-protection
                    const ctx = Aes256.initEnc(self.header_protection_key);
                    var encrypted: [16]u8 = undefined;
                    ctx.encrypt(&encrypted, sample);
                    return encrypted[0..5].*;
                },
                .ChaCha20_Poly1305 => {
                    // https://www.rfc-editor.org/rfc/rfc9001#name-chacha20-based-header-prote
                    //
                    // > The first 4 bytes of the sampled ciphertext are the block counter.
                    // > A ChaCha20 implementation could take a 32-bit integer in place of
                    // > a byte sequence, in which case, the byte sequence is interpreted as
                    // > a **little-endian** value.
                    const counter = mem.readIntLittle(u32, sample[0..4]);

                    // > The remaining 12 bytes are used as the nonce.
                    const nonce = sample[4..16];

                    var out: [5]u8 = undefined;
                    const in: [5]u8 = .{0} ** 5;
                    ChaCha20IETF.xor(&out, &in, counter, self.header_protection_key, nonce);

                    return out;
                },
            }
        }
    };
}

pub const Encryptor = union(enum) {
    AES128_GCM: Algorithm(Aes128Gcm, HmacSha256, HkdfSha256),
    AES256_GCM: Algorithm(Aes256Gcm, HmacSha384, HkdfSha384),
    ChaCha20_Poly1305: Algorithm(ChaCha20Poly1305, HmacSha256, HkdfSha256),

    const Self = @This();

    pub fn deriveMask(self: Self, sample: *const [16]u8) [5]u8 {
        return switch (self) {
            .AES128_GCM => |a| a.deriveMask(sample),
            .AES256_GCM => |a| a.deriveMask(sample),
            .ChaCha20_Poly1305 => |a| a.deriveMask(sample),
        };
    }
};

pub const Decryptor = union(enum) {
    AES128_GCM: Algorithm(Aes128Gcm, HmacSha256, HkdfSha256),
    AES256_GCM: Algorithm(Aes256Gcm, HmacSha384, HkdfSha384),
    ChaCha20_Poly1305: Algorithm(ChaCha20Poly1305, HmacSha256, HkdfSha256),

    const Self = @This();

    pub fn deriveMask(self: Self, sample: *const [16]u8) [5]u8 {
        return switch (self) {
            .AES128_GCM => |a| a.deriveMask(sample),
            .AES256_GCM => |a| a.deriveMask(sample),
            .ChaCha20_Poly1305 => |a| a.deriveMask(sample),
        };
    }
};

const EndpointKind = enum { server, client };

pub fn deriveInitialCryptor(
    comptime kind: EndpointKind,
    destination_connection_id: []const u8,
) !struct { encryptor: Encryptor, decryptor: Decryptor } {
    const common_initial_secret = deriveCommonInitialSecret(destination_connection_id);

    var client_initial_secret: [32]u8 = undefined;
    try deriveClientInitialSecret(HkdfSha256, HmacSha256, &common_initial_secret, &client_initial_secret);

    var server_initial_secret: [32]u8 = undefined;
    try deriveServerInitialSecret(HkdfSha256, HmacSha256, &server_initial_secret, &common_initial_secret);

    return switch (kind) {
        .client => .{
            .encryptor = .{
                .AES128_GCM = try Algorithm(Aes128Gcm, HmacSha256, HkdfSha256).fromSecret(client_initial_secret),
            },
            .decriptor = .{
                .AES128_GCM = try Algorithm(Aes128Gcm, HmacSha256, HkdfSha256).fromSecret(server_initial_secret),
            },
        },
        .server => .{
            .encryptor = .{
                .AES128_GCM = try Algorithm(Aes128Gcm, HmacSha256, HkdfSha256).fromSecret(server_initial_secret),
            },
            .decriptor = .{
                .AES128_GCM = try Algorithm(Aes128Gcm, HmacSha256, HkdfSha256).fromSecret(client_initial_secret),
            },
        },
    };
}

fn deriveCommonInitialSecret(client_destination_connection_id: []const u8) [HmacSha256.mac_length]u8 {
    // https://www.rfc-editor.org/rfc/rfc9001.html#name-initial-secrets
    //
    // > This secret is determined by using HKDF-Extract (see Section 2.2 of [HKDF])
    // > with a salt of 0x38762cf7f55934b34d179ae6a4c80cadccbb7f0a and the input keying
    // > material (IKM) of the Destination Connection ID field.
    const initial_salt = [_]u8{
        0x38, 0x76, 0x2c, 0xf7, 0xf5, 0x59, 0x34, 0xb3,
        0x4d, 0x17, 0x9a, 0xe6, 0xa4, 0xc8, 0x0c, 0xad,
        0xcc, 0xbb, 0x7f, 0x0a,
    };
    return HkdfSha256.extract(&initial_salt, client_destination_connection_id);
}

/// https://www.rfc-editor.org/rfc/rfc9001#name-initial-secrets
fn deriveServerInitialSecret(
    comptime Hkdf: type,
    comptime Hmac: type,
    algo: Algorithm,
    key: []const u8,
    out: []u8,
) !void {
    const label = "server in";
    const ctx = "";
    try hkdfExpandLabel(Hkdf, Hmac, algo, key, label, ctx, out);
}

/// https://www.rfc-editor.org/rfc/rfc9001#name-initial-secrets
fn deriveClientInitialSecret(
    comptime Hkdf: type,
    comptime Hmac: type,
    algo: Algorithm,
    key: []const u8,
    out: []u8,
) !void {
    const label = "client in";
    const ctx = "";
    try hkdfExpandLabel(Hkdf, Hmac, algo, key, label, ctx, out);
}

/// Derives AEAD Key (key) from the given secret.
fn deriveAeadKey(comptime Aead: type, comptime Hmac: type, secret: [Hmac.mac_length]u8) ![Aead.key_length]u8 {
    const label = "quic key";
    const ctx = "";
    var out: [Aead.key_length]u8 = undefined;
    try hkdfExpandLabel(secret, label, ctx, &out);
    return out;
}

/// Derives Initialization Vector (IV) from the given secret.
///
/// https://www.rfc-editor.org/rfc/rfc9001.html#name-packet-protection-keys
///
/// > The Length provided with "quic iv" is the minimum length of the AEAD nonce
/// > or 8 bytes if that is larger
fn deriveInitializationVector(comptime Aead: type, comptime Hmac: type, secret: [Hmac.mac_length]u8) ![Aead.nonce_length]u8 {
    const label = "quic iv";
    const ctx = "";
    var out: [Aead.nonce_length]u8 = undefined;
    try hkdfExpandLabel(secret, label, ctx, &out);
    return out;
}

/// Derives Header Protection Key (hp) from the given secret.
fn deriveHeaderProtectionKey(comptime Aead: type, secret: []const u8) ![Aead.key_length]u8 {
    const label = "quic hp";
    const ctx = "";
    var out: [Aead.key_length]u8 = undefined;
    try hkdfExpandLabel(secret, label, ctx, &out);
    return out;
}

fn hkdfExpandLabel(
    comptime Hkdf: type,
    comptime Hmac: type,
    secret: [Hmac.mac_length]u8,
    label: []const u8,
    ctx: []const u8,
    out: []u8,
) !void {
    if (HkdfLabel.label_prefix.len + label.len > HkdfLabel.label_max_length) {
        return error.LabelTooLong;
    }
    if (ctx.len > HkdfLabel.ctx_max_length) {
        return error.ContextTooLong;
    }

    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();
    const allocator = arena.allocator();

    const hkdfLabel = try HkdfLabel.new(allocator, @as(u16, @intCast(out.len)), label, ctx);

    // TODO(magurotuna): consider more appropriate array size
    var encoded_label: [4096]u8 = undefined;
    var bs = Bytes{ .buf = &encoded_label };
    try hkdfLabel.encode(&bs);

    Hkdf.expand(out, bs.split().former.buf, secret);
}

/// Extract a master key from a salt and initial keying material.
fn hkdfExtract(
    comptime Hkdf: type,
    comptime Hmac: type,
    salt: []const u8,
    initial_keying_material: []const u8,
) [Hmac.mac_length]u8 {
    return Hkdf.extract(salt, initial_keying_material);
}

test "server header protection mask" {
    // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#name-server-initial
    const client_dcid = [_]u8{
        0x83, 0x94, 0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08,
    };
    const cryptor = deriveInitialCryptor(.server, &client_dcid);

    const sample = [_]u8{
        0x2c, 0xd0, 0x99, 0x1c, 0xd2, 0x5b, 0x0a, 0xac,
        0x40, 0x6a, 0x58, 0x16, 0xb6, 0x39, 0x41, 0x00,
    };
    const got = cryptor.encryptor.deriveMask(&sample);

    const expected = [_]u8{
        0x2e, 0xc0, 0xd8, 0x35, 0x6a,
    };
    try std.testing.expectEqualSlices(u8, &expected, &got);
}

test "client header protection mask" {
    // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#name-client-initial
    const client_dcid = [_]u8{
        0x83, 0x94, 0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08,
    };
    const cryptor = deriveInitialCryptor(.client, &client_dcid);

    const sample = [_]u8{
        0xd1, 0xb1, 0xc9, 0x8d, 0xd7, 0x68, 0x9f, 0xb8,
        0xec, 0x11, 0xd2, 0x42, 0xb1, 0x23, 0xdc, 0x9b,
    };
    const got = cryptor.encryptor.deriveMask(&sample);

    const expected = [_]u8{
        0x43, 0x7b, 0x9a, 0xec, 0x36,
    };
    try std.testing.expectEqualSlices(u8, &expected, &got);
}

const HkdfLabel = struct {
    length: u16,
    label: Label,
    context: Context,

    const label_prefix = "tls13 ";
    const label_max_length = 255;
    const ctx_max_length = 255;

    const Self = @This();
    const Label = VariableLengthVector(u8, label_max_length);
    const Context = VariableLengthVector(u8, ctx_max_length);

    fn encodedLength(self: Self) usize {
        var len: usize = 0;
        for (@typeInfo(Self).Struct.fields) |field| {
            len += if (@typeInfo(field.field_type) == .Int)
                utils.sizeOf(field.field_type)
            else
                @field(self, field.name).encodedLength();
        }
        return len;
    }

    fn encode(self: Self, out: *Bytes) !void {
        try out.put(u16, self.length);
        try self.label.encode(out);
        try self.context.encode(out);
    }

    fn new(allocator: std.mem.Allocator, length: u16, label_data: []const u8, context_data: []const u8) !Self {
        const label = blk: {
            var lbl = try Label.fromSlice(allocator, label_prefix);
            errdefer lbl.deinit();
            try lbl.appendSlice(label_data);
            break :blk lbl;
        };
        errdefer label.deinit();

        const context = try Context.fromSlice(allocator, context_data);
        errdefer context.deinit();

        return Self{
            .length = length,
            .label = label,
            .context = context,
        };
    }

    fn deinit(self: Self) void {
        self.label.deinit();
        self.context.deinit();
    }
};

/// Decrypts payload of the packet.
/// Currently it assumes that the given packet is Initial packet sent from the client.
/// TODO(magurotuna): support all types of packets
pub fn decryptPayload(comptime kind: EndpointKind, allocator: mem.Allocator, encrypted_payload: []const u8, unprotected_header: []const u8, packet_number: u32, client_destination_connection_id: []const u8) !ArrayList(u8) {
    // In AEAD_AES_128_GCM, an authentication tag is 16-octet length and present at the end of the payload.
    // https://www.rfc-editor.org/rfc/rfc5116.html#section-5.1
    // TODO(magurotuna): support others: AEAD_AES_256_GCM, AEAD_CHACHA20_POLY1305 and AEAD_AES_128_CCM.
    const tag_length = 16;
    const tag = blk: {
        var t: [tag_length]u8 = undefined;
        mem.copy(u8, &t, encrypted_payload[(encrypted_payload.len - tag_length)..]);
        break :blk t;
    };
    const encrypted_payload_without_tag = encrypted_payload[0..(encrypted_payload.len - tag_length)];

    const initial_secret = blk: {
        var s: [32]u8 = undefined;
        switch (kind) {
            .client => try deriveClientInitialSecret(&s, client_destination_connection_id),
            .server => try deriveServerInitialSecret(&s, client_destination_connection_id),
        }
        break :blk s;
    };

    const nonce = blk: {
        // https://www.rfc-editor.org/rfc/rfc9001#name-aead-usage
        //
        // The nonce, N, is formed by combining the packet protection IV with the packet number.
        // The 62 bits of the reconstructed QUIC packet number in network byte order are
        // left-padded with zeros to the size of the IV. The exclusive OR of the padded packet
        // number and the IV forms the AEAD nonce.
        const iv_length = 12;
        std.debug.assert(iv_length == Aes128Gcm.nonce_length);
        var iv: [iv_length]u8 = undefined;
        try deriveInitializationVector(&iv, initial_secret);
        var pn: [iv_length]u8 = undefined;
        mem.writeIntSliceBig(u32, &pn, packet_number);
        var n: [Aes128Gcm.nonce_length]u8 = undefined;
        for (n, 0..) |_, i| {
            n[i] = pn[i] ^ iv[i];
        }

        break :blk n;
    };

    const key = blk: {
        var k: [16]u8 = undefined;
        try deriveAeadKey(&k, initial_secret);
        break :blk k;
    };

    const decrypted_payload = blk: {
        const out = try allocator.alloc(u8, encrypted_payload_without_tag.len);
        errdefer allocator.free(out);
        try Aes128Gcm.decrypt(out, encrypted_payload_without_tag, tag, unprotected_header, nonce, key);
        break :blk ArrayList(u8).fromOwnedSlice(allocator, out);
    };
    errdefer decrypted_payload.deinit();

    return decrypted_payload;
}

test "decrypt payload of Initial packet sent from a client" {
    // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#name-client-initial

    // zig fmt: off
    const encrypted_payload = [_]u8{
                                            0xd1, 0xb1,
        0xc9, 0x8d, 0xd7, 0x68, 0x9f, 0xb8, 0xec, 0x11,
        0xd2, 0x42, 0xb1, 0x23, 0xdc, 0x9b, 0xd8, 0xba,
        0xb9, 0x36, 0xb4, 0x7d, 0x92, 0xec, 0x35, 0x6c,
        0x0b, 0xab, 0x7d, 0xf5, 0x97, 0x6d, 0x27, 0xcd,
        0x44, 0x9f, 0x63, 0x30, 0x00, 0x99, 0xf3, 0x99,
        0x1c, 0x26, 0x0e, 0xc4, 0xc6, 0x0d, 0x17, 0xb3,
        0x1f, 0x84, 0x29, 0x15, 0x7b, 0xb3, 0x5a, 0x12,
        0x82, 0xa6, 0x43, 0xa8, 0xd2, 0x26, 0x2c, 0xad,
        0x67, 0x50, 0x0c, 0xad, 0xb8, 0xe7, 0x37, 0x8c,
        0x8e, 0xb7, 0x53, 0x9e, 0xc4, 0xd4, 0x90, 0x5f,
        0xed, 0x1b, 0xee, 0x1f, 0xc8, 0xaa, 0xfb, 0xa1,
        0x7c, 0x75, 0x0e, 0x2c, 0x7a, 0xce, 0x01, 0xe6,
        0x00, 0x5f, 0x80, 0xfc, 0xb7, 0xdf, 0x62, 0x12,
        0x30, 0xc8, 0x37, 0x11, 0xb3, 0x93, 0x43, 0xfa,
        0x02, 0x8c, 0xea, 0x7f, 0x7f, 0xb5, 0xff, 0x89,
        0xea, 0xc2, 0x30, 0x82, 0x49, 0xa0, 0x22, 0x52,
        0x15, 0x5e, 0x23, 0x47, 0xb6, 0x3d, 0x58, 0xc5,
        0x45, 0x7a, 0xfd, 0x84, 0xd0, 0x5d, 0xff, 0xfd,
        0xb2, 0x03, 0x92, 0x84, 0x4a, 0xe8, 0x12, 0x15,
        0x46, 0x82, 0xe9, 0xcf, 0x01, 0x2f, 0x90, 0x21,
        0xa6, 0xf0, 0xbe, 0x17, 0xdd, 0xd0, 0xc2, 0x08,
        0x4d, 0xce, 0x25, 0xff, 0x9b, 0x06, 0xcd, 0xe5,
        0x35, 0xd0, 0xf9, 0x20, 0xa2, 0xdb, 0x1b, 0xf3,
        0x62, 0xc2, 0x3e, 0x59, 0x6d, 0x11, 0xa4, 0xf5,
        0xa6, 0xcf, 0x39, 0x48, 0x83, 0x8a, 0x3a, 0xec,
        0x4e, 0x15, 0xda, 0xf8, 0x50, 0x0a, 0x6e, 0xf6,
        0x9e, 0xc4, 0xe3, 0xfe, 0xb6, 0xb1, 0xd9, 0x8e,
        0x61, 0x0a, 0xc8, 0xb7, 0xec, 0x3f, 0xaf, 0x6a,
        0xd7, 0x60, 0xb7, 0xba, 0xd1, 0xdb, 0x4b, 0xa3,
        0x48, 0x5e, 0x8a, 0x94, 0xdc, 0x25, 0x0a, 0xe3,
        0xfd, 0xb4, 0x1e, 0xd1, 0x5f, 0xb6, 0xa8, 0xe5,
        0xeb, 0xa0, 0xfc, 0x3d, 0xd6, 0x0b, 0xc8, 0xe3,
        0x0c, 0x5c, 0x42, 0x87, 0xe5, 0x38, 0x05, 0xdb,
        0x05, 0x9a, 0xe0, 0x64, 0x8d, 0xb2, 0xf6, 0x42,
        0x64, 0xed, 0x5e, 0x39, 0xbe, 0x2e, 0x20, 0xd8,
        0x2d, 0xf5, 0x66, 0xda, 0x8d, 0xd5, 0x99, 0x8c,
        0xca, 0xbd, 0xae, 0x05, 0x30, 0x60, 0xae, 0x6c,
        0x7b, 0x43, 0x78, 0xe8, 0x46, 0xd2, 0x9f, 0x37,
        0xed, 0x7b, 0x4e, 0xa9, 0xec, 0x5d, 0x82, 0xe7,
        0x96, 0x1b, 0x7f, 0x25, 0xa9, 0x32, 0x38, 0x51,
        0xf6, 0x81, 0xd5, 0x82, 0x36, 0x3a, 0xa5, 0xf8,
        0x99, 0x37, 0xf5, 0xa6, 0x72, 0x58, 0xbf, 0x63,
        0xad, 0x6f, 0x1a, 0x0b, 0x1d, 0x96, 0xdb, 0xd4,
        0xfa, 0xdd, 0xfc, 0xef, 0xc5, 0x26, 0x6b, 0xa6,
        0x61, 0x17, 0x22, 0x39, 0x5c, 0x90, 0x65, 0x56,
        0xbe, 0x52, 0xaf, 0xe3, 0xf5, 0x65, 0x63, 0x6a,
        0xd1, 0xb1, 0x7d, 0x50, 0x8b, 0x73, 0xd8, 0x74,
        0x3e, 0xeb, 0x52, 0x4b, 0xe2, 0x2b, 0x3d, 0xcb,
        0xc2, 0xc7, 0x46, 0x8d, 0x54, 0x11, 0x9c, 0x74,
        0x68, 0x44, 0x9a, 0x13, 0xd8, 0xe3, 0xb9, 0x58,
        0x11, 0xa1, 0x98, 0xf3, 0x49, 0x1d, 0xe3, 0xe7,
        0xfe, 0x94, 0x2b, 0x33, 0x04, 0x07, 0xab, 0xf8,
        0x2a, 0x4e, 0xd7, 0xc1, 0xb3, 0x11, 0x66, 0x3a,
        0xc6, 0x98, 0x90, 0xf4, 0x15, 0x70, 0x15, 0x85,
        0x3d, 0x91, 0xe9, 0x23, 0x03, 0x7c, 0x22, 0x7a,
        0x33, 0xcd, 0xd5, 0xec, 0x28, 0x1c, 0xa3, 0xf7,
        0x9c, 0x44, 0x54, 0x6b, 0x9d, 0x90, 0xca, 0x00,
        0xf0, 0x64, 0xc9, 0x9e, 0x3d, 0xd9, 0x79, 0x11,
        0xd3, 0x9f, 0xe9, 0xc5, 0xd0, 0xb2, 0x3a, 0x22,
        0x9a, 0x23, 0x4c, 0xb3, 0x61, 0x86, 0xc4, 0x81,
        0x9e, 0x8b, 0x9c, 0x59, 0x27, 0x72, 0x66, 0x32,
        0x29, 0x1d, 0x6a, 0x41, 0x82, 0x11, 0xcc, 0x29,
        0x62, 0xe2, 0x0f, 0xe4, 0x7f, 0xeb, 0x3e, 0xdf,
        0x33, 0x0f, 0x2c, 0x60, 0x3a, 0x9d, 0x48, 0xc0,
        0xfc, 0xb5, 0x69, 0x9d, 0xbf, 0xe5, 0x89, 0x64,
        0x25, 0xc5, 0xba, 0xc4, 0xae, 0xe8, 0x2e, 0x57,
        0xa8, 0x5a, 0xaf, 0x4e, 0x25, 0x13, 0xe4, 0xf0,
        0x57, 0x96, 0xb0, 0x7b, 0xa2, 0xee, 0x47, 0xd8,
        0x05, 0x06, 0xf8, 0xd2, 0xc2, 0x5e, 0x50, 0xfd,
        0x14, 0xde, 0x71, 0xe6, 0xc4, 0x18, 0x55, 0x93,
        0x02, 0xf9, 0x39, 0xb0, 0xe1, 0xab, 0xd5, 0x76,
        0xf2, 0x79, 0xc4, 0xb2, 0xe0, 0xfe, 0xb8, 0x5c,
        0x1f, 0x28, 0xff, 0x18, 0xf5, 0x88, 0x91, 0xff,
        0xef, 0x13, 0x2e, 0xef, 0x2f, 0xa0, 0x93, 0x46,
        0xae, 0xe3, 0x3c, 0x28, 0xeb, 0x13, 0x0f, 0xf2,
        0x8f, 0x5b, 0x76, 0x69, 0x53, 0x33, 0x41, 0x13,
        0x21, 0x19, 0x96, 0xd2, 0x00, 0x11, 0xa1, 0x98,
        0xe3, 0xfc, 0x43, 0x3f, 0x9f, 0x25, 0x41, 0x01,
        0x0a, 0xe1, 0x7c, 0x1b, 0xf2, 0x02, 0x58, 0x0f,
        0x60, 0x47, 0x47, 0x2f, 0xb3, 0x68, 0x57, 0xfe,
        0x84, 0x3b, 0x19, 0xf5, 0x98, 0x40, 0x09, 0xdd,
        0xc3, 0x24, 0x04, 0x4e, 0x84, 0x7a, 0x4f, 0x4a,
        0x0a, 0xb3, 0x4f, 0x71, 0x95, 0x95, 0xde, 0x37,
        0x25, 0x2d, 0x62, 0x35, 0x36, 0x5e, 0x9b, 0x84,
        0x39, 0x2b, 0x06, 0x10, 0x85, 0x34, 0x9d, 0x73,
        0x20, 0x3a, 0x4a, 0x13, 0xe9, 0x6f, 0x54, 0x32,
        0xec, 0x0f, 0xd4, 0xa1, 0xee, 0x65, 0xac, 0xcd,
        0xd5, 0xe3, 0x90, 0x4d, 0xf5, 0x4c, 0x1d, 0xa5,
        0x10, 0xb0, 0xff, 0x20, 0xdc, 0xc0, 0xc7, 0x7f,
        0xcb, 0x2c, 0x0e, 0x0e, 0xb6, 0x05, 0xcb, 0x05,
        0x04, 0xdb, 0x87, 0x63, 0x2c, 0xf3, 0xd8, 0xb4,
        0xda, 0xe6, 0xe7, 0x05, 0x76, 0x9d, 0x1d, 0xe3,
        0x54, 0x27, 0x01, 0x23, 0xcb, 0x11, 0x45, 0x0e,
        0xfc, 0x60, 0xac, 0x47, 0x68, 0x3d, 0x7b, 0x8d,
        0x0f, 0x81, 0x13, 0x65, 0x56, 0x5f, 0xd9, 0x8c,
        0x4c, 0x8e, 0xb9, 0x36, 0xbc, 0xab, 0x8d, 0x06,
        0x9f, 0xc3, 0x3b, 0xd8, 0x01, 0xb0, 0x3a, 0xde,
        0xa2, 0xe1, 0xfb, 0xc5, 0xaa, 0x46, 0x3d, 0x08,
        0xca, 0x19, 0x89, 0x6d, 0x2b, 0xf5, 0x9a, 0x07,
        0x1b, 0x85, 0x1e, 0x6c, 0x23, 0x90, 0x52, 0x17,
        0x2f, 0x29, 0x6b, 0xfb, 0x5e, 0x72, 0x40, 0x47,
        0x90, 0xa2, 0x18, 0x10, 0x14, 0xf3, 0xb9, 0x4a,
        0x4e, 0x97, 0xd1, 0x17, 0xb4, 0x38, 0x13, 0x03,
        0x68, 0xcc, 0x39, 0xdb, 0xb2, 0xd1, 0x98, 0x06,
        0x5a, 0xe3, 0x98, 0x65, 0x47, 0x92, 0x6c, 0xd2,
        0x16, 0x2f, 0x40, 0xa2, 0x9f, 0x0c, 0x3c, 0x87,
        0x45, 0xc0, 0xf5, 0x0f, 0xba, 0x38, 0x52, 0xe5,
        0x66, 0xd4, 0x45, 0x75, 0xc2, 0x9d, 0x39, 0xa0,
        0x3f, 0x0c, 0xda, 0x72, 0x19, 0x84, 0xb6, 0xf4,
        0x40, 0x59, 0x1f, 0x35, 0x5e, 0x12, 0xd4, 0x39,
        0xff, 0x15, 0x0a, 0xab, 0x76, 0x13, 0x49, 0x9d,
        0xbd, 0x49, 0xad, 0xab, 0xc8, 0x67, 0x6e, 0xef,
        0x02, 0x3b, 0x15, 0xb6, 0x5b, 0xfc, 0x5c, 0xa0,
        0x69, 0x48, 0x10, 0x9f, 0x23, 0xf3, 0x50, 0xdb,
        0x82, 0x12, 0x35, 0x35, 0xeb, 0x8a, 0x74, 0x33,
        0xbd, 0xab, 0xcb, 0x90, 0x92, 0x71, 0xa6, 0xec,
        0xbc, 0xb5, 0x8b, 0x93, 0x6a, 0x88, 0xcd, 0x4e,
        0x8f, 0x2e, 0x6f, 0xf5, 0x80, 0x01, 0x75, 0xf1,
        0x13, 0x25, 0x3d, 0x8f, 0xa9, 0xca, 0x88, 0x85,
        0xc2, 0xf5, 0x52, 0xe6, 0x57, 0xdc, 0x60, 0x3f,
        0x25, 0x2e, 0x1a, 0x8e, 0x30, 0x8f, 0x76, 0xf0,
        0xbe, 0x79, 0xe2, 0xfb, 0x8f, 0x5d, 0x5f, 0xbb,
        0xe2, 0xe3, 0x0e, 0xca, 0xdd, 0x22, 0x07, 0x23,
        0xc8, 0xc0, 0xae, 0xa8, 0x07, 0x8c, 0xdf, 0xcb,
        0x38, 0x68, 0x26, 0x3f, 0xf8, 0xf0, 0x94, 0x00,
        0x54, 0xda, 0x48, 0x78, 0x18, 0x93, 0xa7, 0xe4,
        0x9a, 0xd5, 0xaf, 0xf4, 0xaf, 0x30, 0x0c, 0xd8,
        0x04, 0xa6, 0xb6, 0x27, 0x9a, 0xb3, 0xff, 0x3a,
        0xfb, 0x64, 0x49, 0x1c, 0x85, 0x19, 0x4a, 0xab,
        0x76, 0x0d, 0x58, 0xa6, 0x06, 0x65, 0x4f, 0x9f,
        0x44, 0x00, 0xe8, 0xb3, 0x85, 0x91, 0x35, 0x6f,
        0xbf, 0x64, 0x25, 0xac, 0xa2, 0x6d, 0xc8, 0x52,
        0x44, 0x25, 0x9f, 0xf2, 0xb1, 0x9c, 0x41, 0xb9,
        0xf9, 0x6f, 0x3c, 0xa9, 0xec, 0x1d, 0xde, 0x43,
        0x4d, 0xa7, 0xd2, 0xd3, 0x92, 0xb9, 0x05, 0xdd,
        0xf3, 0xd1, 0xf9, 0xaf, 0x93, 0xd1, 0xaf, 0x59,
        0x50, 0xbd, 0x49, 0x3f, 0x5a, 0xa7, 0x31, 0xb4,
        0x05, 0x6d, 0xf3, 0x1b, 0xd2, 0x67, 0xb6, 0xb9,
        0x0a, 0x07, 0x98, 0x31, 0xaa, 0xf5, 0x79, 0xbe,
        0x0a, 0x39, 0x01, 0x31, 0x37, 0xaa, 0xc6, 0xd4,
        0x04, 0xf5, 0x18, 0xcf, 0xd4, 0x68, 0x40, 0x64,
        0x7e, 0x78, 0xbf, 0xe7, 0x06, 0xca, 0x4c, 0xf5,
        0xe9, 0xc5, 0x45, 0x3e, 0x9f, 0x7c, 0xfd, 0x2b,
        0x8b, 0x4c, 0x8d, 0x16, 0x9a, 0x44, 0xe5, 0x5c,
        0x88, 0xd4, 0xa9, 0xa7, 0xf9, 0x47, 0x42, 0x41,
        0xe2, 0x21, 0xaf, 0x44, 0x86, 0x00, 0x18, 0xab,
        0x08, 0x56, 0x97, 0x2e, 0x19, 0x4c, 0xd9, 0x34,
    };
    // zig fmt: on

    // zig fmt: off
    const unprotected_header = [_]u8{
        0xc3, 0x00, 0x00, 0x00, 0x01, 0x08, 0x83, 0x94,
        0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08, 0x00, 0x00,
        0x44, 0x9e, 0x00, 0x00, 0x00, 0x02,
    };
    // zig fmt: on

    const packet_number = 2;

    // zig fmt: off
    const client_dcid = [_]u8{
        0x83, 0x94, 0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08,
    };
    // zig fmt: on

    const got = try decryptPayload(.client, std.testing.allocator, &encrypted_payload, &unprotected_header, packet_number, &client_dcid);
    defer got.deinit();

    const expected = blk: {
        // Copied from https://www.rfc-editor.org/rfc/rfc9001#name-client-initial
        // zig fmt: off
        const crypto_frame = [_]u8{
            0x06, 0x00, 0x40, 0xf1, 0x01, 0x00, 0x00, 0xed,
            0x03, 0x03, 0xeb, 0xf8, 0xfa, 0x56, 0xf1, 0x29,
            0x39, 0xb9, 0x58, 0x4a, 0x38, 0x96, 0x47, 0x2e,
            0xc4, 0x0b, 0xb8, 0x63, 0xcf, 0xd3, 0xe8, 0x68,
            0x04, 0xfe, 0x3a, 0x47, 0xf0, 0x6a, 0x2b, 0x69,
            0x48, 0x4c, 0x00, 0x00, 0x04, 0x13, 0x01, 0x13,
            0x02, 0x01, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00,
            0x10, 0x00, 0x0e, 0x00, 0x00, 0x0b, 0x65, 0x78,
            0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x63, 0x6f,
            0x6d, 0xff, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0a,
            0x00, 0x08, 0x00, 0x06, 0x00, 0x1d, 0x00, 0x17,
            0x00, 0x18, 0x00, 0x10, 0x00, 0x07, 0x00, 0x05,
            0x04, 0x61, 0x6c, 0x70, 0x6e, 0x00, 0x05, 0x00,
            0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33,
            0x00, 0x26, 0x00, 0x24, 0x00, 0x1d, 0x00, 0x20,
            0x93, 0x70, 0xb2, 0xc9, 0xca, 0xa4, 0x7f, 0xba,
            0xba, 0xf4, 0x55, 0x9f, 0xed, 0xba, 0x75, 0x3d,
            0xe1, 0x71, 0xfa, 0x71, 0xf5, 0x0f, 0x1c, 0xe1,
            0x5d, 0x43, 0xe9, 0x94, 0xec, 0x74, 0xd7, 0x48,
            0x00, 0x2b, 0x00, 0x03, 0x02, 0x03, 0x04, 0x00,
            0x0d, 0x00, 0x10, 0x00, 0x0e, 0x04, 0x03, 0x05,
            0x03, 0x06, 0x03, 0x02, 0x03, 0x08, 0x04, 0x08,
            0x05, 0x08, 0x06, 0x00, 0x2d, 0x00, 0x02, 0x01,
            0x01, 0x00, 0x1c, 0x00, 0x02, 0x40, 0x01, 0x00,
            0x39, 0x00, 0x32, 0x04, 0x08, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0x05, 0x04, 0x80,
            0x00, 0xff, 0xff, 0x07, 0x04, 0x80, 0x00, 0xff,
            0xff, 0x08, 0x01, 0x10, 0x01, 0x04, 0x80, 0x00,
            0x75, 0x30, 0x09, 0x01, 0x10, 0x0f, 0x08, 0x83,
            0x94, 0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08, 0x06,
            0x04, 0x80, 0x00, 0xff, 0xff,
        };
        // zig fmt: on

        // PADDING frames are added to make the packet reach 1200 bytes, since clients MUST ensure that
        // UDP datagrams containing Initial packets have UDP payloads of at least 1200 bytes.
        // Note that `1162` is `1200 - header_size (22 bytes, in this case) - authentication_tag_size (16 bytes)`.
        //
        // https://www.rfc-editor.org/rfc/rfc9000.html#name-address-validation-during-c
        // https://www.rfc-editor.org/rfc/rfc9001#name-client-initial
        const padding_frames = [_]u8{0x00} ** (1162 - crypto_frame.len);

        break :blk crypto_frame ++ padding_frames;
    };

    try std.testing.expectEqualSlices(u8, &expected, got.items);
}

/// Encrypt payload using various information such as unprotected header, packet number, and Destination Connection ID that the client determines.
///
/// https://www.rfc-editor.org/rfc/rfc9001.html#name-aead-usage
pub fn encryptPayload(comptime kind: EndpointKind, allocator: mem.Allocator, payload: []const u8, header: []const u8, packet_number: u32, client_destination_connection_id: []const u8) !ArrayList(u8) {
    const initial_secret = blk: {
        var s: [32]u8 = undefined;
        switch (kind) {
            .client => try deriveClientInitialSecret(&s, client_destination_connection_id),
            .server => try deriveServerInitialSecret(&s, client_destination_connection_id),
        }
        break :blk s;
    };

    const nonce = blk: {
        // https://www.rfc-editor.org/rfc/rfc9001#name-aead-usage
        //
        // The nonce, N, is formed by combining the packet protection IV with the packet number.
        // The 62 bits of the reconstructed QUIC packet number in network byte order are
        // left-padded with zeros to the size of the IV. The exclusive OR of the padded packet
        // number and the IV forms the AEAD nonce.
        const iv_length = 12;
        std.debug.assert(iv_length == Aes128Gcm.nonce_length);
        var iv: [iv_length]u8 = undefined;
        try deriveInitializationVector(&iv, initial_secret);
        var pn: [iv_length]u8 = undefined;
        mem.writeIntSliceBig(u32, &pn, packet_number);
        var n: [Aes128Gcm.nonce_length]u8 = undefined;
        for (n, 0..) |_, i| {
            n[i] = pn[i] ^ iv[i];
        }

        break :blk n;
    };

    const key = blk: {
        var k: [16]u8 = undefined;
        try deriveAeadKey(&k, initial_secret);
        break :blk k;
    };

    const encrypted_payload = blk: {
        const out = try allocator.alloc(u8, payload.len);
        errdefer allocator.free(out);

        var tag: [16]u8 = undefined;
        Aes128Gcm.encrypt(out, &tag, payload, header, nonce, key);

        var encrypted = ArrayList(u8).fromOwnedSlice(allocator, out);
        errdefer encrypted.deinit();

        // Append the auth tag to the encrypted payload.
        try encrypted.appendSlice(&tag);

        break :blk encrypted;
    };
    errdefer encrypted_payload.deinit();

    return encrypted_payload;
}

test "encryptPayload" {
    // Copied from https://www.rfc-editor.org/rfc/rfc9001.html#name-server-initial
    const raw_payload = [_]u8{
        0x02, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x40,
        0x5a, 0x02, 0x00, 0x00, 0x56, 0x03, 0x03, 0xee,
        0xfc, 0xe7, 0xf7, 0xb3, 0x7b, 0xa1, 0xd1, 0x63,
        0x2e, 0x96, 0x67, 0x78, 0x25, 0xdd, 0xf7, 0x39,
        0x88, 0xcf, 0xc7, 0x98, 0x25, 0xdf, 0x56, 0x6d,
        0xc5, 0x43, 0x0b, 0x9a, 0x04, 0x5a, 0x12, 0x00,
        0x13, 0x01, 0x00, 0x00, 0x2e, 0x00, 0x33, 0x00,
        0x24, 0x00, 0x1d, 0x00, 0x20, 0x9d, 0x3c, 0x94,
        0x0d, 0x89, 0x69, 0x0b, 0x84, 0xd0, 0x8a, 0x60,
        0x99, 0x3c, 0x14, 0x4e, 0xca, 0x68, 0x4d, 0x10,
        0x81, 0x28, 0x7c, 0x83, 0x4d, 0x53, 0x11, 0xbc,
        0xf3, 0x2b, 0xb9, 0xda, 0x1a, 0x00, 0x2b, 0x00,
        0x02, 0x03, 0x04,
    };

    const raw_header = [_]u8{
        0xc1, 0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0xf0,
        0x67, 0xa5, 0x50, 0x2a, 0x42, 0x62, 0xb5, 0x00,
        0x40, 0x75, 0x00, 0x01,
    };

    const packet_number = 1;

    const client_dcid = [_]u8{
        0x83, 0x94, 0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08,
    };

    const expected = [_]u8{
        0x5a, 0x48, 0x2c, 0xd0, 0x99, 0x1c, 0xd2, 0x5b,
        0x0a, 0xac, 0x40, 0x6a, 0x58, 0x16, 0xb6, 0x39,
        0x41, 0x00, 0xf3, 0x7a, 0x1c, 0x69, 0x79, 0x75,
        0x54, 0x78, 0x0b, 0xb3, 0x8c, 0xc5, 0xa9, 0x9f,
        0x5e, 0xde, 0x4c, 0xf7, 0x3c, 0x3e, 0xc2, 0x49,
        0x3a, 0x18, 0x39, 0xb3, 0xdb, 0xcb, 0xa3, 0xf6,
        0xea, 0x46, 0xc5, 0xb7, 0x68, 0x4d, 0xf3, 0x54,
        0x8e, 0x7d, 0xde, 0xb9, 0xc3, 0xbf, 0x9c, 0x73,
        0xcc, 0x3f, 0x3b, 0xde, 0xd7, 0x4b, 0x56, 0x2b,
        0xfb, 0x19, 0xfb, 0x84, 0x02, 0x2f, 0x8e, 0xf4,
        0xcd, 0xd9, 0x37, 0x95, 0xd7, 0x7d, 0x06, 0xed,
        0xbb, 0x7a, 0xaf, 0x2f, 0x58, 0x89, 0x18, 0x50,
        0xab, 0xbd, 0xca, 0x3d, 0x20, 0x39, 0x8c, 0x27,
        0x64, 0x56, 0xcb, 0xc4, 0x21, 0x58, 0x40, 0x7d,
        0xd0, 0x74, 0xee,
    };

    const got = try encryptPayload(.server, std.testing.allocator, &raw_payload, &raw_header, packet_number, &client_dcid);
    defer got.deinit();

    try std.testing.expectEqualSlices(u8, &expected, got.items);
}

test "Doing encryptPayload then decryptPayload, can we get the original payload?" {
    // Copied from https://www.rfc-editor.org/rfc/rfc9001.html#name-server-initial
    const raw_payload = [_]u8{
        0x02, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x40,
        0x5a, 0x02, 0x00, 0x00, 0x56, 0x03, 0x03, 0xee,
        0xfc, 0xe7, 0xf7, 0xb3, 0x7b, 0xa1, 0xd1, 0x63,
        0x2e, 0x96, 0x67, 0x78, 0x25, 0xdd, 0xf7, 0x39,
        0x88, 0xcf, 0xc7, 0x98, 0x25, 0xdf, 0x56, 0x6d,
        0xc5, 0x43, 0x0b, 0x9a, 0x04, 0x5a, 0x12, 0x00,
        0x13, 0x01, 0x00, 0x00, 0x2e, 0x00, 0x33, 0x00,
        0x24, 0x00, 0x1d, 0x00, 0x20, 0x9d, 0x3c, 0x94,
        0x0d, 0x89, 0x69, 0x0b, 0x84, 0xd0, 0x8a, 0x60,
        0x99, 0x3c, 0x14, 0x4e, 0xca, 0x68, 0x4d, 0x10,
        0x81, 0x28, 0x7c, 0x83, 0x4d, 0x53, 0x11, 0xbc,
        0xf3, 0x2b, 0xb9, 0xda, 0x1a, 0x00, 0x2b, 0x00,
        0x02, 0x03, 0x04,
    };

    const raw_header = [_]u8{
        0xc1, 0x00, 0x00, 0x00, 0x01, 0x00, 0x08, 0xf0,
        0x67, 0xa5, 0x50, 0x2a, 0x42, 0x62, 0xb5, 0x00,
        0x40, 0x75, 0x00, 0x01,
    };

    const packet_number = 1;

    const client_dcid = [_]u8{
        0x83, 0x94, 0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08,
    };

    const expected_encrypted = [_]u8{
        0x5a, 0x48, 0x2c, 0xd0, 0x99, 0x1c, 0xd2, 0x5b,
        0x0a, 0xac, 0x40, 0x6a, 0x58, 0x16, 0xb6, 0x39,
        0x41, 0x00, 0xf3, 0x7a, 0x1c, 0x69, 0x79, 0x75,
        0x54, 0x78, 0x0b, 0xb3, 0x8c, 0xc5, 0xa9, 0x9f,
        0x5e, 0xde, 0x4c, 0xf7, 0x3c, 0x3e, 0xc2, 0x49,
        0x3a, 0x18, 0x39, 0xb3, 0xdb, 0xcb, 0xa3, 0xf6,
        0xea, 0x46, 0xc5, 0xb7, 0x68, 0x4d, 0xf3, 0x54,
        0x8e, 0x7d, 0xde, 0xb9, 0xc3, 0xbf, 0x9c, 0x73,
        0xcc, 0x3f, 0x3b, 0xde, 0xd7, 0x4b, 0x56, 0x2b,
        0xfb, 0x19, 0xfb, 0x84, 0x02, 0x2f, 0x8e, 0xf4,
        0xcd, 0xd9, 0x37, 0x95, 0xd7, 0x7d, 0x06, 0xed,
        0xbb, 0x7a, 0xaf, 0x2f, 0x58, 0x89, 0x18, 0x50,
        0xab, 0xbd, 0xca, 0x3d, 0x20, 0x39, 0x8c, 0x27,
        0x64, 0x56, 0xcb, 0xc4, 0x21, 0x58, 0x40, 0x7d,
        0xd0, 0x74, 0xee,
    };

    const got_encrypted = try encryptPayload(.server, std.testing.allocator, &raw_payload, &raw_header, packet_number, &client_dcid);
    defer got_encrypted.deinit();

    try std.testing.expectEqualSlices(u8, &expected_encrypted, got_encrypted.items);

    const got_decrypted = try decryptPayload(.server, std.testing.allocator, got_encrypted.items, &raw_header, packet_number, &client_dcid);
    defer got_decrypted.deinit();
    try std.testing.expectEqualSlices(u8, &raw_payload, got_decrypted.items);
}

test "initial_secret" {
    {
        // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#section-a.1
        const client_dcid = [_]u8{
            0x83, 0x94, 0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08,
        };

        const algo = Algorithm.AES128_GCM;
        const mac_length = comptime algo.mac_length();
        var got: u8[mac_length] = undefined;
        deriveCommonInitialSecret(algo, &got, &client_dcid);

        const expected = [_]u8{
            0x7d, 0xb5, 0xdf, 0x06, 0xe7, 0xa6, 0x9e, 0x43,
            0x24, 0x96, 0xad, 0xed, 0xb0, 0x08, 0x51, 0x92,
            0x35, 0x95, 0x22, 0x15, 0x96, 0xae, 0x2a, 0xe9,
            0xfb, 0x81, 0x15, 0xc1, 0xe9, 0xed, 0x0a, 0x44,
        };

        try std.testing.expectEqualSlices(u8, &expected, &got);
    }

    {
        // This test case is brought from https://quic.xargs.org/
        const client_dcid = [_]u8{
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        };

        const algo = Algorithm.AES128_GCM;
        const mac_length = comptime algo.mac_length();
        var got: u8[mac_length] = undefined;
        deriveCommonInitialSecret(algo, &got, &client_dcid);

        const expected = [_]u8{
            0xf0, 0x16, 0xbb, 0x2d, 0xc9, 0x97, 0x6d, 0xea,
            0x27, 0x26, 0xc4, 0xe6, 0x1e, 0x73, 0x8a, 0x1e,
            0x36, 0x80, 0xa2, 0x48, 0x75, 0x91, 0xdc, 0x76,
            0xb2, 0xae, 0xe2, 0xed, 0x75, 0x98, 0x22, 0xf6,
        };

        try std.testing.expectEqualSlices(u8, &expected, &got);
    }
}

test "server_initial_secret" {
    {
        // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#section-a.1
        var out: [32]u8 = undefined;
        // zig fmt: off
        const client_dcid = [_]u8{
            0x83, 0x94, 0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08,
        };
        // zig fmt: on
        try deriveServerInitialSecret(&out, &client_dcid);

        // zig fmt: off
        const expected = [_]u8{
            0x3c, 0x19, 0x98, 0x28, 0xfd, 0x13, 0x9e, 0xfd,
            0x21, 0x6c, 0x15, 0x5a, 0xd8, 0x44, 0xcc, 0x81,
            0xfb, 0x82, 0xfa, 0x8d, 0x74, 0x46, 0xfa, 0x7d,
            0x78, 0xbe, 0x80, 0x3a, 0xcd, 0xda, 0x95, 0x1b
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }

    {
        // This test case is brought from https://quic.xargs.org/
        var out: [32]u8 = undefined;
        // zig fmt: off
        const client_dcid = [_]u8{
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        };
        // zig fmt: on
        try deriveServerInitialSecret(&out, &client_dcid);

        // zig fmt: off
        const expected = [_]u8{
            0xad, 0xc1, 0x99, 0x5b, 0x5c, 0xee, 0x8f, 0x03,
            0x74, 0x6b, 0xf8, 0x30, 0x9d, 0x02, 0xd5, 0xea,
            0x27, 0x15, 0x9c, 0x1e, 0xd6, 0x91, 0x54, 0x03,
            0xb3, 0x63, 0x18, 0xd5, 0xa0, 0x3a, 0xfe, 0xb8,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }
}

test "client_initial_secret" {
    {
        // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#section-a.1
        var out: [32]u8 = undefined;
        // zig fmt: off
        const client_dcid = [_]u8{
            0x83, 0x94, 0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08,
        };
        // zig fmt: on
        try deriveClientInitialSecret(&out, &client_dcid);

        // zig fmt: off
        const expected = [_]u8{
            0xc0, 0x0c, 0xf1, 0x51, 0xca, 0x5b, 0xe0, 0x75,
            0xed, 0x0e, 0xbf, 0xb5, 0xc8, 0x03, 0x23, 0xc4,
            0x2d, 0x6b, 0x7d, 0xb6, 0x78, 0x81, 0x28, 0x9a,
            0xf4, 0x00, 0x8f, 0x1f, 0x6c, 0x35, 0x7a, 0xea,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }

    {
        // This test case is brought from https://quic.xargs.org/
        var out: [32]u8 = undefined;
        // zig fmt: off
        const client_dcid = [_]u8{
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        };
        // zig fmt: on
        try deriveClientInitialSecret(&out, &client_dcid);

        // zig fmt: off
        const expected = [_]u8{
            0x47, 0xc6, 0xa6, 0x38, 0xd4, 0x96, 0x85, 0x95,
            0xcc, 0x20, 0xb7, 0xc8, 0xbc, 0x5f, 0xbf, 0xbf,
            0xd0, 0x2d, 0x7c, 0x17, 0xcc, 0x67, 0xfa, 0x54,
            0x8c, 0x04, 0x3e, 0xcb, 0x54, 0x7b, 0x0e, 0xaa,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }
}

test "AEAD key" {
    {
        // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#section-a.1
        var out: [16]u8 = undefined;
        // zig fmt: off
        const server_initial_secret = [_]u8{
            0x3c, 0x19, 0x98, 0x28, 0xfd, 0x13, 0x9e, 0xfd,
            0x21, 0x6c, 0x15, 0x5a, 0xd8, 0x44, 0xcc, 0x81,
            0xfb, 0x82, 0xfa, 0x8d, 0x74, 0x46, 0xfa, 0x7d,
            0x78, 0xbe, 0x80, 0x3a, 0xcd, 0xda, 0x95, 0x1b
        };
        // zig fmt: on
        try deriveAeadKey(&out, server_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0xcf, 0x3a, 0x53, 0x31, 0x65, 0x3c, 0x36, 0x4c,
            0x88, 0xf0, 0xf3, 0x79, 0xb6, 0x06, 0x7e, 0x37,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }

    {
        // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#section-a.1
        var out: [16]u8 = undefined;
        // zig fmt: off
        const client_initial_secret = [_]u8 {
            0xc0, 0x0c, 0xf1, 0x51, 0xca, 0x5b, 0xe0, 0x75,
            0xed, 0x0e, 0xbf, 0xb5, 0xc8, 0x03, 0x23, 0xc4,
            0x2d, 0x6b, 0x7d, 0xb6, 0x78, 0x81, 0x28, 0x9a,
            0xf4, 0x00, 0x8f, 0x1f, 0x6c, 0x35, 0x7a, 0xea,
        };
        // zig fmt: on
        try deriveAeadKey(&out, client_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0x1f, 0x36, 0x96, 0x13, 0xdd, 0x76, 0xd5, 0x46,
            0x77, 0x30, 0xef, 0xcb, 0xe3, 0xb1, 0xa2, 0x2d,
        };
        // zig fmt: on
        try std.testing.expectEqualSlices(u8, &expected, &out);
    }

    {
        // This test case is brought from https://quic.xargs.org/
        var out: [16]u8 = undefined;
        // zig fmt: off
        const server_initial_secret = [_]u8{
            0xad, 0xc1, 0x99, 0x5b, 0x5c, 0xee, 0x8f, 0x03,
            0x74, 0x6b, 0xf8, 0x30, 0x9d, 0x02, 0xd5, 0xea,
            0x27, 0x15, 0x9c, 0x1e, 0xd6, 0x91, 0x54, 0x03,
            0xb3, 0x63, 0x18, 0xd5, 0xa0, 0x3a, 0xfe, 0xb8,
        };
        // zig fmt: on
        try deriveAeadKey(&out, server_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0xd7, 0x7f, 0xc4, 0x05, 0x6f, 0xcf, 0xa3, 0x2b,
            0xd1, 0x30, 0x24, 0x69, 0xee, 0x6e, 0xbf, 0x90,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }

    {
        // This test case is brought from https://quic.xargs.org/
        var out: [16]u8 = undefined;
        // zig fmt: off
        const client_initial_secret = [_]u8{
            0x47, 0xc6, 0xa6, 0x38, 0xd4, 0x96, 0x85, 0x95,
            0xcc, 0x20, 0xb7, 0xc8, 0xbc, 0x5f, 0xbf, 0xbf,
            0xd0, 0x2d, 0x7c, 0x17, 0xcc, 0x67, 0xfa, 0x54,
            0x8c, 0x04, 0x3e, 0xcb, 0x54, 0x7b, 0x0e, 0xaa,
        };
        // zig fmt: on
        try deriveAeadKey(&out, client_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0xb1, 0x4b, 0x91, 0x81, 0x24, 0xfd, 0xa5, 0xc8,
            0xd7, 0x98, 0x47, 0x60, 0x2f, 0xa3, 0x52, 0x0b,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }
}

test "Initialization Vector (IV)" {
    {
        // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#section-a.1
        var out: [12]u8 = undefined;
        // zig fmt: off
        const server_initial_secret = [_]u8{
            0x3c, 0x19, 0x98, 0x28, 0xfd, 0x13, 0x9e, 0xfd,
            0x21, 0x6c, 0x15, 0x5a, 0xd8, 0x44, 0xcc, 0x81,
            0xfb, 0x82, 0xfa, 0x8d, 0x74, 0x46, 0xfa, 0x7d,
            0x78, 0xbe, 0x80, 0x3a, 0xcd, 0xda, 0x95, 0x1b
        };
        // zig fmt: on
        try deriveInitializationVector(&out, server_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0x0a, 0xc1, 0x49, 0x3c, 0xa1, 0x90, 0x58, 0x53,
            0xb0, 0xbb, 0xa0, 0x3e,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }

    {
        // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#section-a.1
        var out: [12]u8 = undefined;
        // zig fmt: off
        const client_initial_secret = [_]u8{
            0xc0, 0x0c, 0xf1, 0x51, 0xca, 0x5b, 0xe0, 0x75,
            0xed, 0x0e, 0xbf, 0xb5, 0xc8, 0x03, 0x23, 0xc4,
            0x2d, 0x6b, 0x7d, 0xb6, 0x78, 0x81, 0x28, 0x9a,
            0xf4, 0x00, 0x8f, 0x1f, 0x6c, 0x35, 0x7a, 0xea,
        };
        // zig fmt: on
        try deriveInitializationVector(&out, client_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0xfa, 0x04, 0x4b, 0x2f, 0x42, 0xa3, 0xfd, 0x3b,
            0x46, 0xfb, 0x25, 0x5c,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }

    {
        // This test case is brought from https://quic.xargs.org/
        var out: [12]u8 = undefined;
        // zig fmt: off
        const server_initial_secret = [_]u8{
            0xad, 0xc1, 0x99, 0x5b, 0x5c, 0xee, 0x8f, 0x03,
            0x74, 0x6b, 0xf8, 0x30, 0x9d, 0x02, 0xd5, 0xea,
            0x27, 0x15, 0x9c, 0x1e, 0xd6, 0x91, 0x54, 0x03,
            0xb3, 0x63, 0x18, 0xd5, 0xa0, 0x3a, 0xfe, 0xb8,
        };
        // zig fmt: on
        try deriveInitializationVector(&out, server_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0xfc, 0xb7, 0x48, 0xe3, 0x7f, 0xf7, 0x98, 0x60,
            0xfa, 0xa0, 0x74, 0x77,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }

    {
        // This test case is brought from https://quic.xargs.org/
        var out: [12]u8 = undefined;
        // zig fmt: off
        const client_initial_secret = [_]u8{
            0x47, 0xc6, 0xa6, 0x38, 0xd4, 0x96, 0x85, 0x95,
            0xcc, 0x20, 0xb7, 0xc8, 0xbc, 0x5f, 0xbf, 0xbf,
            0xd0, 0x2d, 0x7c, 0x17, 0xcc, 0x67, 0xfa, 0x54,
            0x8c, 0x04, 0x3e, 0xcb, 0x54, 0x7b, 0x0e, 0xaa,
        };
        // zig fmt: on
        try deriveInitializationVector(&out, client_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0xdd, 0xbc, 0x15, 0xde, 0xa8, 0x09, 0x25, 0xa5,
            0x56, 0x86, 0xa7, 0xdf,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }
}

test "header protection key" {
    {
        // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#section-a.1
        var out: [16]u8 = undefined;
        // zig fmt: off
        const server_initial_secret = [_]u8{
            0x3c, 0x19, 0x98, 0x28, 0xfd, 0x13, 0x9e, 0xfd,
            0x21, 0x6c, 0x15, 0x5a, 0xd8, 0x44, 0xcc, 0x81,
            0xfb, 0x82, 0xfa, 0x8d, 0x74, 0x46, 0xfa, 0x7d,
            0x78, 0xbe, 0x80, 0x3a, 0xcd, 0xda, 0x95, 0x1b
        };
        // zig fmt: on
        try deriveHeaderProtectionKey(&out, server_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0xc2, 0x06, 0xb8, 0xd9, 0xb9, 0xf0, 0xf3, 0x76,
            0x44, 0x43, 0x0b, 0x49, 0x0e, 0xea, 0xa3, 0x14,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }

    {
        // This test case is brought from https://www.rfc-editor.org/rfc/rfc9001#section-a.1
        var out: [16]u8 = undefined;
        // zig fmt: off
        const client_initial_secret = [_]u8{
            0xc0, 0x0c, 0xf1, 0x51, 0xca, 0x5b, 0xe0, 0x75,
            0xed, 0x0e, 0xbf, 0xb5, 0xc8, 0x03, 0x23, 0xc4,
            0x2d, 0x6b, 0x7d, 0xb6, 0x78, 0x81, 0x28, 0x9a,
            0xf4, 0x00, 0x8f, 0x1f, 0x6c, 0x35, 0x7a, 0xea,
        };
        // zig fmt: on
        try deriveHeaderProtectionKey(&out, client_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0x9f, 0x50, 0x44, 0x9e, 0x04, 0xa0, 0xe8, 0x10,
            0x28, 0x3a, 0x1e, 0x99, 0x33, 0xad, 0xed, 0xd2,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }

    {
        // This test case is brought from https://quic.xargs.org/
        var out: [16]u8 = undefined;
        // zig fmt: off
        const server_initial_secret = [_]u8{
            0xad, 0xc1, 0x99, 0x5b, 0x5c, 0xee, 0x8f, 0x03,
            0x74, 0x6b, 0xf8, 0x30, 0x9d, 0x02, 0xd5, 0xea,
            0x27, 0x15, 0x9c, 0x1e, 0xd6, 0x91, 0x54, 0x03,
            0xb3, 0x63, 0x18, 0xd5, 0xa0, 0x3a, 0xfe, 0xb8,
        };
        // zig fmt: on
        try deriveHeaderProtectionKey(&out, server_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0x44, 0x0b, 0x27, 0x25, 0xe9, 0x1d, 0xc7, 0x9b,
            0x37, 0x07, 0x11, 0xef, 0x79, 0x2f, 0xaa, 0x3d,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }

    {
        // This test case is brought from https://quic.xargs.org/
        var out: [16]u8 = undefined;
        // zig fmt: off
        const client_initial_secret = [_]u8{
            0x47, 0xc6, 0xa6, 0x38, 0xd4, 0x96, 0x85, 0x95,
            0xcc, 0x20, 0xb7, 0xc8, 0xbc, 0x5f, 0xbf, 0xbf,
            0xd0, 0x2d, 0x7c, 0x17, 0xcc, 0x67, 0xfa, 0x54,
            0x8c, 0x04, 0x3e, 0xcb, 0x54, 0x7b, 0x0e, 0xaa,
        };
        // zig fmt: on
        try deriveHeaderProtectionKey(&out, client_initial_secret);

        // zig fmt: off
        const expected = [_]u8{
            0x6d, 0xf4, 0xe9, 0xd7, 0x37, 0xcd, 0xf7, 0x14,
            0x71, 0x1d, 0x7c, 0x61, 0x7e, 0xe8, 0x29, 0x81,
        };
        // zig fmt: on

        try std.testing.expectEqualSlices(u8, &expected, &out);
    }
}
