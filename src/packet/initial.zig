const std = @import("std");
const mem = std.mem;
const log = std.log;
const ArrayList = std.ArrayList;
const bytes = @import("../bytes.zig");
const isSupported = @import("../version.zig").isSupported;
const quic_v1 = @import("../version.zig").quic_v1;
const max_cid_len = @import("../packet.zig").max_cid_len;
const crypto = @import("../crypto.zig");
const Aes128 = std.crypto.core.aes.Aes128;
const Frame = @import("../frame/frame.zig").Frame;
const FrameType = @import("../frame/frame.zig").FrameType;
const utils = @import("../utils.zig");

/// An Initial Packet
/// https://www.rfc-editor.org/rfc/rfc9000.html#name-initial-packet
/// https://www.rfc-editor.org/rfc/rfc9001#name-header-protection-applicati
///
/// Initial Packet {
///     Header Form (1) = 1,
///     Fixed Bit (1) = 1,
///     Long Packet Type (2) = 0,
///     Reserved Bits (2),         # Protected. The value included prior to protection MUST be set to 0.
///     Packet Number Length (2),  # Protected. The length of the Packet Number field is the unprotected value of this field plus one.
///     Version (32),
///     Destination Connection ID Length (8),
///     Destination Connection ID (0..160),
///     Source Connection ID Length (8),
///     Source Connection ID (0..160),
///     Token Length (i),
///     Token (..),
///     Length (i),
///     Packet Number (8..32),     # Protected
///     Packet Payload (8..),      # Encrypted
/// }
pub const Initial = struct {
    /// QUIC version identifier.
    version: u32 = quic_v1,
    /// Destination connection ID of the packet.
    /// Although in QUIC v1 the maximum length is 20 bytes, the implementation should
    /// accept Connection ID with its length being over 20 bytes so it can handle QUIC
    /// packets of future versions, as explained here: https://www.rfc-editor.org/rfc/rfc9000.html#section-17.2-3.12.1
    /// So we use `ArrayList(u8)` rather than `BoundedArray(u8, 20)`.
    destination_connection_id: ArrayList(u8),
    /// Source connection ID of the packet.
    /// Although in QUIC v1 the maximum length is 20 bytes, the implementation should
    /// accept Connection ID with its length being over 20 bytes so it can handle QUIC
    /// packets of future versions, as explained here: https://www.rfc-editor.org/rfc/rfc9000.html#section-17.2-3.12.1
    /// So we use `ArrayList(u8)` rather than `BoundedArray(u8, 20)`.
    source_connection_id: ArrayList(u8),
    /// Address verification token.
    token: ArrayList(u8),
    /// Packet number.
    packet_number: u32,
    /// Payload of the packet.
    payload: ArrayList(Frame),

    const Self = @This();

    /// Encodes the Initial packet and write it to `out`, with the payload being encrypted and the header being protected.
    /// Note that it only supports Server Initial right now.
    pub fn encode(self: Self, out: *bytes.Bytes) !void {
        var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
        defer arena.deinit();
        const allocator = arena.allocator();

        // Encode the payload without encryption.
        // TODO(magurotuna): find out more appropriate size
        var payload_buf = try allocator.alloc(u8, 65536);
        var payload_bytes = bytes.Bytes{ .buf = payload_buf };
        for (self.payload.items) |frame| {
            try frame.encode(&payload_bytes);
        }
        const raw_payload = payload_bytes.split().former.buf;

        // Encode the header without protection.
        // TODO(magurotuna): find out more appropriate size
        var header_buf = try allocator.alloc(u8, 1024);
        var header_bytes = bytes.Bytes{ .buf = header_buf };
        try self.encode_header_no_protect(&header_bytes);
        const raw_header = header_bytes.split().former.buf;

        const client_destination_connection_id = self.source_connection_id.items;
        // Encrypt the payload.
        const encrypted_payload = try crypto.encryptPayload(.server, allocator, raw_payload, raw_header, self.packet_number, client_destination_connection_id);

        // Protect the header.
        const protected_header = blk: {
            var header = try allocator.dupe(u8, raw_header);

            // https://www.rfc-editor.org/rfc/rfc9001#name-header-protection-sample
            const sample_length = 16;
            // Since we always use `4` as the length of the Packet Number field for the moment,
            // sample can be taken from the very first byte of encrypted_payload.
            const sample = encrypted_payload.items[0..sample_length];

            const mask = try crypto.getServerHeaderProtectionMask(Aes128, client_destination_connection_id, sample);
            // https://www.rfc-editor.org/rfc/rfc9001#name-header-protection-applicati
            //
            // # Long header: 4 bits masked
            // packet[0] ^= mask[0] & 0x0f
            header[0] ^= mask[0] & 0x0f;

            // We are allowed to use any number between 1 to 4 as the length of Packet Number.
            // https://www.rfc-editor.org/rfc/rfc9000.html#name-long-header-packets
            // To keep things simple, we use the maximum length `4` as the length of the Packet Number field,
            // because this can accomodate all possible packet numbers.
            const packet_number_length = 4;
            std.debug.assert(packet_number_length <= 4);

            // https://www.rfc-editor.org/rfc/rfc9001.html#name-header-protection-applicati
            //
            // # pn_offset is the start of the Packet Number field.
            // packet[pn_offset:pn_offset+pn_length] ^= mask[1:1+pn_length]
            const hlen = header.len;
            const packet_number_offset = hlen - packet_number_length;
            {
                var i: usize = 0;
                while (i < packet_number_length) : (i += 1) {
                    header[packet_number_offset + i] ^= mask[1 + i];
                }
            }

            break :blk header;
        };

        // Write everything into `out`.
        try out.putBytes(protected_header);
        try out.putBytes(encrypted_payload.items);
    }

    /// Encodes the header part of the Initial packet and write it to `out`.
    /// It will NOT do any protection on the written data.
    fn encode_header_no_protect(self: Self, out: *bytes.Bytes) !void {
        // We are allowed to use any number between 1 to 4 as the length of Packet Number.
        // https://www.rfc-editor.org/rfc/rfc9000.html#name-long-header-packets
        // To keep things simple, we use the maximum length `4` as the length of the Packet Number field,
        // because this can accomodate all possible packet numbers.
        const packet_number_length = 4;
        std.debug.assert(packet_number_length <= 4);

        // TODO(magurotuna): AEAD length is hardcoded here for now, and we are sure that it works fine.
        // Probably it would be better to manage this value somewhere else.
        //
        // As a reference, we can find the information on the hardcoded value here:
        // https://datatracker.ietf.org/doc/html/rfc5116#section-5.1
        //
        // > An AEAD_AES_128_GCM ciphertext is exactly 16 octets longer than its corresponding plaintext.
        //
        // > The AEAD_AES_128_GCM ciphertext is formed by appending the authentication tag provided as an
        // > output to the GCM encryption operation to the ciphertext that is output by that operation.
        //
        // We can also find in RFC 9001: https://www.rfc-editor.org/rfc/rfc9001.html#name-aead-usage
        //
        // > These cipher suites have a 16-byte authentication tag and produce an output 16 bytes larger
        // > than their input.
        const aead_tag_length = 16;

        const first_byte: u8 = blk: {
            const header_form = 1 << 7;
            const fixed_bit = 1 << 6;
            const long_packet_type = 0;
            const reserved_bits = 0;
            const packet_number_length_minus_1 = @as(u8, @intCast(packet_number_length)) - 1;
            break :blk header_form ^ fixed_bit ^ long_packet_type ^ reserved_bits ^ packet_number_length_minus_1;
        };
        try out.put(u8, first_byte);

        // Version
        try out.put(u32, self.version);
        // Destination Connection ID Length
        try out.put(u8, @as(u8, @intCast(self.destination_connection_id.items.len)));
        // Destination Connection ID
        try out.putBytes(self.destination_connection_id.items);
        // Source Connection ID Length
        try out.put(u8, @as(u8, @intCast(self.source_connection_id.items.len)));
        // Source Connection ID
        try out.putBytes(self.source_connection_id.items);
        // Token Length
        try out.putVarInt(@as(u64, @intCast(self.token.items.len)));
        // Token
        try out.putBytes(self.token.items);
        // Length
        try out.putVarInt(@as(u64, @intCast(packet_number_length + payload_len: {
            var len: usize = 0;
            for (self.payload.items) |f| {
                len += f.encodedLength();
            }
            break :payload_len len;
        } + aead_tag_length)));
        // Packet Number
        try out.put(u32, self.packet_number);
    }

    /// Decodes the input bytes, assuming that the bytes are coming from a client, not from a server.
    pub fn decode(allocator: std.mem.Allocator, in: *bytes.Bytes) !Self {
        // Ensure that `in` has not been consumed yet.
        std.debug.assert(in.pos == 0);

        const first_byte = try in.consume(u8);
        const version = try in.consume(u32);

        const dcid_len = try in.consume(u8);
        log.debug("destination connection id length: {}\n", .{dcid_len});
        if (isSupported(version) and dcid_len > max_cid_len)
            return error.InvalidPacket;

        const dcid = try in.consumeBytesOwned(allocator, dcid_len);
        log.debug("destination connection id: {}\n", .{std.fmt.fmtSliceHexLower(dcid.items)});
        errdefer dcid.deinit();

        const scid_len = try in.consume(u8);
        log.debug("source connection id length: {}\n", .{scid_len});
        if (isSupported(version) and scid_len > max_cid_len)
            return error.InvalidPacket;

        const scid = try in.consumeBytesOwned(allocator, scid_len);
        log.debug("source connection id: {}\n", .{std.fmt.fmtSliceHexLower(scid.items)});
        errdefer scid.deinit();

        const token = try in.consumeBytesOwnedWithVarIntLength(allocator);
        errdefer token.deinit();

        const packet_number_and_payload = try in.consumeBytesOwnedWithVarIntLength(allocator);
        defer packet_number_and_payload.deinit();

        // The original byte stream `in` might contain multiple QUIC packets. We want to decode
        // one packet at the moment, so we create another `Bytes` that views only one packet we're focusing on.
        var packet_bytes = bytes.Bytes{ .buf = in.buf[0..in.pos] };
        log.debug("packet bytes: {}\n", .{std.fmt.fmtSliceHexLower(packet_bytes.buf)});

        // https://www.rfc-editor.org/rfc/rfc9001#name-header-protection-sample
        const sample_length = 16;
        const sample = packet_number_and_payload.items[4..(4 + sample_length)];

        const mask = try crypto.getClientHeaderProtectionMask(Aes128, dcid.items, sample);
        // https://www.rfc-editor.org/rfc/rfc9001#name-header-protection-applicati
        //
        // # Long header: 4 bits masked
        // packet[0] ^= mask[0] & 0x0f
        const unprotected_first = first_byte ^ (mask[0] & 0x0f);

        const packet_number_length = (unprotected_first & 0x03) + 1;
        log.debug("packet number length: {}\n", .{packet_number_length});

        const packet_number = blk: {
            const max_packet_number_length = 4;
            var pn = [_]u8{0x00} ** max_packet_number_length;
            var i: usize = 0;
            while (i < packet_number_length) : (i += 1) {
                pn[i] = packet_number_and_payload.items[i] ^ mask[1 + i];
            }
            break :blk mem.readVarInt(u32, pn[0..packet_number_length], .Big);
        };
        log.debug("packet number: {}\n", .{packet_number});

        const payload_bytes = blk: {
            const encrypted_payload = packet_number_and_payload.items[packet_number_length..];

            const unprotected_header = hdr: {
                // Set unprotected first byte
                const h = packet_bytes.buf[0..(packet_bytes.buf.len - encrypted_payload.len)];
                h[0] = unprotected_first;

                // Set unprotected Packet Number field.
                // First we encode the raw (unprotected) packet number as a big-endian u32 value,
                // then mutate the Packet Number space with the subarray of the encoded packet number,
                // whose length is equal to `packet_number_length`.
                var pn_big_endian: [4]u8 = undefined;
                mem.writeIntBig(u32, &pn_big_endian, packet_number);
                const sub = pn_big_endian[(pn_big_endian.len - packet_number_length)..];
                var packet_number_space = h[(h.len - packet_number_length)..];
                mem.copy(u8, packet_number_space, sub);

                break :hdr h;
            };

            break :blk try crypto.decryptPayload(.client, allocator, encrypted_payload, unprotected_header, packet_number, dcid.items);
        };
        defer payload_bytes.deinit();

        const frames = blk: {
            var buf = bytes.Bytes{ .buf = payload_bytes.items };
            var fs = ArrayList(Frame).init(allocator);
            errdefer {
                for (fs.items) |item| {
                    item.deinit();
                }
                fs.deinit();
            }

            decode_frames: while (true) {
                const f = Frame.decode(allocator, &buf) catch |e| {
                    // In case of `BufferTooShort` it indicates all frames have been decoded.
                    if (e == bytes.Bytes.Error.BufferTooShort)
                        break :decode_frames;

                    return e;
                };
                errdefer f.deinit();
                try fs.append(f);
            }

            break :blk fs;
        };
        errdefer frames.deinit();

        return Self{
            .version = version,
            .destination_connection_id = dcid,
            .source_connection_id = scid,
            .token = token,
            .packet_number = packet_number,
            .payload = frames,
        };
    }

    pub fn deinit(self: Self) void {
        self.destination_connection_id.deinit();
        self.source_connection_id.deinit();
        self.token.deinit();
        for (self.payload.items) |item| {
            item.deinit();
        }
        self.payload.deinit();
    }
};

test "encode Server Initial" {
    const ServerHello = @import("../tls/server_hello.zig").ServerHello;
    const KeyExchange = @import("../tls/extension/key_share.zig").KeyExchange;
    const AckRanges = @import("../frame/ack.zig").Ack.AckRanges;

    // Brought from https://quic.xargs.org/
    const server_initial = Initial{
        .destination_connection_id = blk: {
            var dcid = try ArrayList(u8).initCapacity(std.testing.allocator, 6);
            dcid.appendSliceAssumeCapacity(&.{ 0x05, 0x63, 0x5f, 0x63, 0x69, 0x64 });
            break :blk dcid;
        },
        .source_connection_id = blk: {
            var scid = try ArrayList(u8).initCapacity(std.testing.allocator, 6);
            scid.appendSliceAssumeCapacity(&.{ 0x05, 0x73, 0x5f, 0x63, 0x69, 0x64 });
            break :blk scid;
        },
        .token = ArrayList(u8).init(std.testing.allocator),
        .packet_number = 0,
        .payload = blk: {
            var frames = try ArrayList(Frame).initCapacity(std.testing.allocator, 2);
            frames.appendSliceAssumeCapacity(&.{
                .{
                    .ack = .{
                        .largest_acknowledged = 0,
                        .ack_delay = 0x42_40,
                        .first_ack_range = 0,
                        .ack_range = AckRanges.init(std.testing.allocator),
                    },
                },
                .{
                    .crypto = .{
                        .offset = 0,
                        .crypto_data = .{
                            .server_hello = .{
                                .random = .{
                                    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
                                    0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
                                    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
                                    0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
                                },
                                .legacy_session_id_echo = try ServerHello.LegacySessionId.fromSlice(std.testing.allocator, &.{0}),
                                .cipher_suite = .TLS_AES_128_GCM_SHA256,
                                .extensions = try ServerHello.Extensions.fromSlice(std.testing.allocator, &.{
                                    .{
                                        .key_share = .{
                                            .server_share = .{
                                                .group = .x25519,
                                                .key_exchange = try KeyExchange.fromSlice(std.testing.allocator, &.{
                                                    0x9f, 0xd7, 0xad, 0x6d, 0xcf, 0xf4, 0x29, 0x8d,
                                                    0xd3, 0xf9, 0x6d, 0x5b, 0x1b, 0x2a, 0xf9, 0x10,
                                                    0xa0, 0x53, 0x5b, 0x14, 0x88, 0xd7, 0xf8, 0xfa,
                                                    0xbb, 0x34, 0x9a, 0x98, 0x28, 0x80, 0xb6, 0x15,
                                                }),
                                            },
                                        },
                                    },
                                    .{
                                        .supported_versions = .{
                                            .selected_version = 0x03_04,
                                        },
                                    },
                                }),
                            },
                        },
                    },
                },
            });
            break :blk frames;
        },
    };
    defer server_initial.deinit();

    var buf: [1024]u8 = undefined;
    var out = bytes.Bytes{ .buf = &buf };

    try server_initial.encode(&out);

    // TODO(magurotuna): add more assertions
}

test "decode Client Initial from RFC 9001" {
    // https://www.rfc-editor.org/rfc/rfc9001#name-client-initial
    // zig fmt: off
    var in = [_]u8{
        ///////////////////////////////////////////////
        // header
        ///////////////////////////////////////////////
        0xc0, 0x00, 0x00, 0x00, 0x01, 0x08, 0x83, 0x94,
        0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08, 0x00, 0x00,
        0x44, 0x9e, 0x7b, 0x9a, 0xec, 0x34,

        ///////////////////////////////////////////////
        // payload
        ///////////////////////////////////////////////
                                            0xd1, 0xb1,
        0xc9, 0x8d, 0xd7, 0x68, 0x9f, 0xb8, 0xec, 0x11,
        0xd2, 0x42, 0xb1, 0x23, 0xdc, 0x9b, 0xd8, 0xba,
        0xb9, 0x36, 0xb4, 0x7d, 0x92, 0xec, 0x35, 0x6c,
        0x0b, 0xab, 0x7d, 0xf5, 0x97, 0x6d, 0x27, 0xcd,
        0x44, 0x9f, 0x63, 0x30, 0x00, 0x99, 0xf3, 0x99,
        0x1c, 0x26, 0x0e, 0xc4, 0xc6, 0x0d, 0x17, 0xb3,
        0x1f, 0x84, 0x29, 0x15, 0x7b, 0xb3, 0x5a, 0x12,
        0x82, 0xa6, 0x43, 0xa8, 0xd2, 0x26, 0x2c, 0xad,
        0x67, 0x50, 0x0c, 0xad, 0xb8, 0xe7, 0x37, 0x8c,
        0x8e, 0xb7, 0x53, 0x9e, 0xc4, 0xd4, 0x90, 0x5f,
        0xed, 0x1b, 0xee, 0x1f, 0xc8, 0xaa, 0xfb, 0xa1,
        0x7c, 0x75, 0x0e, 0x2c, 0x7a, 0xce, 0x01, 0xe6,
        0x00, 0x5f, 0x80, 0xfc, 0xb7, 0xdf, 0x62, 0x12,
        0x30, 0xc8, 0x37, 0x11, 0xb3, 0x93, 0x43, 0xfa,
        0x02, 0x8c, 0xea, 0x7f, 0x7f, 0xb5, 0xff, 0x89,
        0xea, 0xc2, 0x30, 0x82, 0x49, 0xa0, 0x22, 0x52,
        0x15, 0x5e, 0x23, 0x47, 0xb6, 0x3d, 0x58, 0xc5,
        0x45, 0x7a, 0xfd, 0x84, 0xd0, 0x5d, 0xff, 0xfd,
        0xb2, 0x03, 0x92, 0x84, 0x4a, 0xe8, 0x12, 0x15,
        0x46, 0x82, 0xe9, 0xcf, 0x01, 0x2f, 0x90, 0x21,
        0xa6, 0xf0, 0xbe, 0x17, 0xdd, 0xd0, 0xc2, 0x08,
        0x4d, 0xce, 0x25, 0xff, 0x9b, 0x06, 0xcd, 0xe5,
        0x35, 0xd0, 0xf9, 0x20, 0xa2, 0xdb, 0x1b, 0xf3,
        0x62, 0xc2, 0x3e, 0x59, 0x6d, 0x11, 0xa4, 0xf5,
        0xa6, 0xcf, 0x39, 0x48, 0x83, 0x8a, 0x3a, 0xec,
        0x4e, 0x15, 0xda, 0xf8, 0x50, 0x0a, 0x6e, 0xf6,
        0x9e, 0xc4, 0xe3, 0xfe, 0xb6, 0xb1, 0xd9, 0x8e,
        0x61, 0x0a, 0xc8, 0xb7, 0xec, 0x3f, 0xaf, 0x6a,
        0xd7, 0x60, 0xb7, 0xba, 0xd1, 0xdb, 0x4b, 0xa3,
        0x48, 0x5e, 0x8a, 0x94, 0xdc, 0x25, 0x0a, 0xe3,
        0xfd, 0xb4, 0x1e, 0xd1, 0x5f, 0xb6, 0xa8, 0xe5,
        0xeb, 0xa0, 0xfc, 0x3d, 0xd6, 0x0b, 0xc8, 0xe3,
        0x0c, 0x5c, 0x42, 0x87, 0xe5, 0x38, 0x05, 0xdb,
        0x05, 0x9a, 0xe0, 0x64, 0x8d, 0xb2, 0xf6, 0x42,
        0x64, 0xed, 0x5e, 0x39, 0xbe, 0x2e, 0x20, 0xd8,
        0x2d, 0xf5, 0x66, 0xda, 0x8d, 0xd5, 0x99, 0x8c,
        0xca, 0xbd, 0xae, 0x05, 0x30, 0x60, 0xae, 0x6c,
        0x7b, 0x43, 0x78, 0xe8, 0x46, 0xd2, 0x9f, 0x37,
        0xed, 0x7b, 0x4e, 0xa9, 0xec, 0x5d, 0x82, 0xe7,
        0x96, 0x1b, 0x7f, 0x25, 0xa9, 0x32, 0x38, 0x51,
        0xf6, 0x81, 0xd5, 0x82, 0x36, 0x3a, 0xa5, 0xf8,
        0x99, 0x37, 0xf5, 0xa6, 0x72, 0x58, 0xbf, 0x63,
        0xad, 0x6f, 0x1a, 0x0b, 0x1d, 0x96, 0xdb, 0xd4,
        0xfa, 0xdd, 0xfc, 0xef, 0xc5, 0x26, 0x6b, 0xa6,
        0x61, 0x17, 0x22, 0x39, 0x5c, 0x90, 0x65, 0x56,
        0xbe, 0x52, 0xaf, 0xe3, 0xf5, 0x65, 0x63, 0x6a,
        0xd1, 0xb1, 0x7d, 0x50, 0x8b, 0x73, 0xd8, 0x74,
        0x3e, 0xeb, 0x52, 0x4b, 0xe2, 0x2b, 0x3d, 0xcb,
        0xc2, 0xc7, 0x46, 0x8d, 0x54, 0x11, 0x9c, 0x74,
        0x68, 0x44, 0x9a, 0x13, 0xd8, 0xe3, 0xb9, 0x58,
        0x11, 0xa1, 0x98, 0xf3, 0x49, 0x1d, 0xe3, 0xe7,
        0xfe, 0x94, 0x2b, 0x33, 0x04, 0x07, 0xab, 0xf8,
        0x2a, 0x4e, 0xd7, 0xc1, 0xb3, 0x11, 0x66, 0x3a,
        0xc6, 0x98, 0x90, 0xf4, 0x15, 0x70, 0x15, 0x85,
        0x3d, 0x91, 0xe9, 0x23, 0x03, 0x7c, 0x22, 0x7a,
        0x33, 0xcd, 0xd5, 0xec, 0x28, 0x1c, 0xa3, 0xf7,
        0x9c, 0x44, 0x54, 0x6b, 0x9d, 0x90, 0xca, 0x00,
        0xf0, 0x64, 0xc9, 0x9e, 0x3d, 0xd9, 0x79, 0x11,
        0xd3, 0x9f, 0xe9, 0xc5, 0xd0, 0xb2, 0x3a, 0x22,
        0x9a, 0x23, 0x4c, 0xb3, 0x61, 0x86, 0xc4, 0x81,
        0x9e, 0x8b, 0x9c, 0x59, 0x27, 0x72, 0x66, 0x32,
        0x29, 0x1d, 0x6a, 0x41, 0x82, 0x11, 0xcc, 0x29,
        0x62, 0xe2, 0x0f, 0xe4, 0x7f, 0xeb, 0x3e, 0xdf,
        0x33, 0x0f, 0x2c, 0x60, 0x3a, 0x9d, 0x48, 0xc0,
        0xfc, 0xb5, 0x69, 0x9d, 0xbf, 0xe5, 0x89, 0x64,
        0x25, 0xc5, 0xba, 0xc4, 0xae, 0xe8, 0x2e, 0x57,
        0xa8, 0x5a, 0xaf, 0x4e, 0x25, 0x13, 0xe4, 0xf0,
        0x57, 0x96, 0xb0, 0x7b, 0xa2, 0xee, 0x47, 0xd8,
        0x05, 0x06, 0xf8, 0xd2, 0xc2, 0x5e, 0x50, 0xfd,
        0x14, 0xde, 0x71, 0xe6, 0xc4, 0x18, 0x55, 0x93,
        0x02, 0xf9, 0x39, 0xb0, 0xe1, 0xab, 0xd5, 0x76,
        0xf2, 0x79, 0xc4, 0xb2, 0xe0, 0xfe, 0xb8, 0x5c,
        0x1f, 0x28, 0xff, 0x18, 0xf5, 0x88, 0x91, 0xff,
        0xef, 0x13, 0x2e, 0xef, 0x2f, 0xa0, 0x93, 0x46,
        0xae, 0xe3, 0x3c, 0x28, 0xeb, 0x13, 0x0f, 0xf2,
        0x8f, 0x5b, 0x76, 0x69, 0x53, 0x33, 0x41, 0x13,
        0x21, 0x19, 0x96, 0xd2, 0x00, 0x11, 0xa1, 0x98,
        0xe3, 0xfc, 0x43, 0x3f, 0x9f, 0x25, 0x41, 0x01,
        0x0a, 0xe1, 0x7c, 0x1b, 0xf2, 0x02, 0x58, 0x0f,
        0x60, 0x47, 0x47, 0x2f, 0xb3, 0x68, 0x57, 0xfe,
        0x84, 0x3b, 0x19, 0xf5, 0x98, 0x40, 0x09, 0xdd,
        0xc3, 0x24, 0x04, 0x4e, 0x84, 0x7a, 0x4f, 0x4a,
        0x0a, 0xb3, 0x4f, 0x71, 0x95, 0x95, 0xde, 0x37,
        0x25, 0x2d, 0x62, 0x35, 0x36, 0x5e, 0x9b, 0x84,
        0x39, 0x2b, 0x06, 0x10, 0x85, 0x34, 0x9d, 0x73,
        0x20, 0x3a, 0x4a, 0x13, 0xe9, 0x6f, 0x54, 0x32,
        0xec, 0x0f, 0xd4, 0xa1, 0xee, 0x65, 0xac, 0xcd,
        0xd5, 0xe3, 0x90, 0x4d, 0xf5, 0x4c, 0x1d, 0xa5,
        0x10, 0xb0, 0xff, 0x20, 0xdc, 0xc0, 0xc7, 0x7f,
        0xcb, 0x2c, 0x0e, 0x0e, 0xb6, 0x05, 0xcb, 0x05,
        0x04, 0xdb, 0x87, 0x63, 0x2c, 0xf3, 0xd8, 0xb4,
        0xda, 0xe6, 0xe7, 0x05, 0x76, 0x9d, 0x1d, 0xe3,
        0x54, 0x27, 0x01, 0x23, 0xcb, 0x11, 0x45, 0x0e,
        0xfc, 0x60, 0xac, 0x47, 0x68, 0x3d, 0x7b, 0x8d,
        0x0f, 0x81, 0x13, 0x65, 0x56, 0x5f, 0xd9, 0x8c,
        0x4c, 0x8e, 0xb9, 0x36, 0xbc, 0xab, 0x8d, 0x06,
        0x9f, 0xc3, 0x3b, 0xd8, 0x01, 0xb0, 0x3a, 0xde,
        0xa2, 0xe1, 0xfb, 0xc5, 0xaa, 0x46, 0x3d, 0x08,
        0xca, 0x19, 0x89, 0x6d, 0x2b, 0xf5, 0x9a, 0x07,
        0x1b, 0x85, 0x1e, 0x6c, 0x23, 0x90, 0x52, 0x17,
        0x2f, 0x29, 0x6b, 0xfb, 0x5e, 0x72, 0x40, 0x47,
        0x90, 0xa2, 0x18, 0x10, 0x14, 0xf3, 0xb9, 0x4a,
        0x4e, 0x97, 0xd1, 0x17, 0xb4, 0x38, 0x13, 0x03,
        0x68, 0xcc, 0x39, 0xdb, 0xb2, 0xd1, 0x98, 0x06,
        0x5a, 0xe3, 0x98, 0x65, 0x47, 0x92, 0x6c, 0xd2,
        0x16, 0x2f, 0x40, 0xa2, 0x9f, 0x0c, 0x3c, 0x87,
        0x45, 0xc0, 0xf5, 0x0f, 0xba, 0x38, 0x52, 0xe5,
        0x66, 0xd4, 0x45, 0x75, 0xc2, 0x9d, 0x39, 0xa0,
        0x3f, 0x0c, 0xda, 0x72, 0x19, 0x84, 0xb6, 0xf4,
        0x40, 0x59, 0x1f, 0x35, 0x5e, 0x12, 0xd4, 0x39,
        0xff, 0x15, 0x0a, 0xab, 0x76, 0x13, 0x49, 0x9d,
        0xbd, 0x49, 0xad, 0xab, 0xc8, 0x67, 0x6e, 0xef,
        0x02, 0x3b, 0x15, 0xb6, 0x5b, 0xfc, 0x5c, 0xa0,
        0x69, 0x48, 0x10, 0x9f, 0x23, 0xf3, 0x50, 0xdb,
        0x82, 0x12, 0x35, 0x35, 0xeb, 0x8a, 0x74, 0x33,
        0xbd, 0xab, 0xcb, 0x90, 0x92, 0x71, 0xa6, 0xec,
        0xbc, 0xb5, 0x8b, 0x93, 0x6a, 0x88, 0xcd, 0x4e,
        0x8f, 0x2e, 0x6f, 0xf5, 0x80, 0x01, 0x75, 0xf1,
        0x13, 0x25, 0x3d, 0x8f, 0xa9, 0xca, 0x88, 0x85,
        0xc2, 0xf5, 0x52, 0xe6, 0x57, 0xdc, 0x60, 0x3f,
        0x25, 0x2e, 0x1a, 0x8e, 0x30, 0x8f, 0x76, 0xf0,
        0xbe, 0x79, 0xe2, 0xfb, 0x8f, 0x5d, 0x5f, 0xbb,
        0xe2, 0xe3, 0x0e, 0xca, 0xdd, 0x22, 0x07, 0x23,
        0xc8, 0xc0, 0xae, 0xa8, 0x07, 0x8c, 0xdf, 0xcb,
        0x38, 0x68, 0x26, 0x3f, 0xf8, 0xf0, 0x94, 0x00,
        0x54, 0xda, 0x48, 0x78, 0x18, 0x93, 0xa7, 0xe4,
        0x9a, 0xd5, 0xaf, 0xf4, 0xaf, 0x30, 0x0c, 0xd8,
        0x04, 0xa6, 0xb6, 0x27, 0x9a, 0xb3, 0xff, 0x3a,
        0xfb, 0x64, 0x49, 0x1c, 0x85, 0x19, 0x4a, 0xab,
        0x76, 0x0d, 0x58, 0xa6, 0x06, 0x65, 0x4f, 0x9f,
        0x44, 0x00, 0xe8, 0xb3, 0x85, 0x91, 0x35, 0x6f,
        0xbf, 0x64, 0x25, 0xac, 0xa2, 0x6d, 0xc8, 0x52,
        0x44, 0x25, 0x9f, 0xf2, 0xb1, 0x9c, 0x41, 0xb9,
        0xf9, 0x6f, 0x3c, 0xa9, 0xec, 0x1d, 0xde, 0x43,
        0x4d, 0xa7, 0xd2, 0xd3, 0x92, 0xb9, 0x05, 0xdd,
        0xf3, 0xd1, 0xf9, 0xaf, 0x93, 0xd1, 0xaf, 0x59,
        0x50, 0xbd, 0x49, 0x3f, 0x5a, 0xa7, 0x31, 0xb4,
        0x05, 0x6d, 0xf3, 0x1b, 0xd2, 0x67, 0xb6, 0xb9,
        0x0a, 0x07, 0x98, 0x31, 0xaa, 0xf5, 0x79, 0xbe,
        0x0a, 0x39, 0x01, 0x31, 0x37, 0xaa, 0xc6, 0xd4,
        0x04, 0xf5, 0x18, 0xcf, 0xd4, 0x68, 0x40, 0x64,
        0x7e, 0x78, 0xbf, 0xe7, 0x06, 0xca, 0x4c, 0xf5,
        0xe9, 0xc5, 0x45, 0x3e, 0x9f, 0x7c, 0xfd, 0x2b,
        0x8b, 0x4c, 0x8d, 0x16, 0x9a, 0x44, 0xe5, 0x5c,
        0x88, 0xd4, 0xa9, 0xa7, 0xf9, 0x47, 0x42, 0x41,
        0xe2, 0x21, 0xaf, 0x44, 0x86, 0x00, 0x18, 0xab,
        0x08, 0x56, 0x97, 0x2e, 0x19, 0x4c, 0xd9, 0x34,
    };
    // zig fmt: on

    var bs = bytes.Bytes{ .buf = &in };
    const got = try Initial.decode(std.testing.allocator, &bs);
    defer got.deinit();

    // See if the header part is correctly decoded.
    try std.testing.expectEqual(@as(u32, quic_v1), got.version);
    try std.testing.expectEqualSlices(
        u8,
        &[_]u8{ 0x83, 0x94, 0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08 },
        got.destination_connection_id.items,
    );
    try std.testing.expectEqual(@as(usize, 0), got.source_connection_id.items.len);
    try std.testing.expectEqual(@as(usize, 0), got.token.items.len);
    try std.testing.expectEqual(@as(u32, 2), got.packet_number);

    // See if the payload part is correctly decoded.

    // Contains 1 CRYPTO frame and 917 PADDING frames
    try std.testing.expectEqual(@as(usize, 918), got.payload.items.len);

    // The first frame is CRYPTO
    try std.testing.expectEqual(FrameType.crypto, got.payload.items[0]);
    // The rest frames are all PADDING
    for (got.payload.items[1..]) |f| {
        try std.testing.expectEqual(FrameType.padding, f);
        try std.testing.expectEqual(@as(u64, 0x00), f.padding.frame_type);
    }
}

test "decode Client Initial from 'The Illustrated QUIC Connection'" {
    // https://quic.xargs.org/
    // zig fmt: off
    var in = [_]u8{
        0xcd, 0x00, 0x00, 0x00, 0x01, 0x08, 0x00, 0x01,
        0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x05, 0x63,
        0x5f, 0x63, 0x69, 0x64, 0x00, 0x41, 0x03, 0x98,
        0x1c, 0x36, 0xa7, 0xed, 0x78, 0x71, 0x6b, 0xe9,
        0x71, 0x1b, 0xa4, 0x98, 0xb7, 0xed, 0x86, 0x84,
        0x43, 0xbb, 0x2e, 0x0c, 0x51, 0x4d, 0x4d, 0x84,
        0x8e, 0xad, 0xcc, 0x7a, 0x00, 0xd2, 0x5c, 0xe9,
        0xf9, 0xaf, 0xa4, 0x83, 0x97, 0x80, 0x88, 0xde,
        0x83, 0x6b, 0xe6, 0x8c, 0x0b, 0x32, 0xa2, 0x45,
        0x95, 0xd7, 0x81, 0x3e, 0xa5, 0x41, 0x4a, 0x91,
        0x99, 0x32, 0x9a, 0x6d, 0x9f, 0x7f, 0x76, 0x0d,
        0xd8, 0xbb, 0x24, 0x9b, 0xf3, 0xf5, 0x3d, 0x9a,
        0x77, 0xfb, 0xb7, 0xb3, 0x95, 0xb8, 0xd6, 0x6d,
        0x78, 0x79, 0xa5, 0x1f, 0xe5, 0x9e, 0xf9, 0x60,
        0x1f, 0x79, 0x99, 0x8e, 0xb3, 0x56, 0x8e, 0x1f,
        0xdc, 0x78, 0x9f, 0x64, 0x0a, 0xca, 0xb3, 0x85,
        0x8a, 0x82, 0xef, 0x29, 0x30, 0xfa, 0x5c, 0xe1,
        0x4b, 0x5b, 0x9e, 0xa0, 0xbd, 0xb2, 0x9f, 0x45,
        0x72, 0xda, 0x85, 0xaa, 0x3d, 0xef, 0x39, 0xb7,
        0xef, 0xaf, 0xff, 0xa0, 0x74, 0xb9, 0x26, 0x70,
        0x70, 0xd5, 0x0b, 0x5d, 0x07, 0x84, 0x2e, 0x49,
        0xbb, 0xa3, 0xbc, 0x78, 0x7f, 0xf2, 0x95, 0xd6,
        0xae, 0x3b, 0x51, 0x43, 0x05, 0xf1, 0x02, 0xaf,
        0xe5, 0xa0, 0x47, 0xb3, 0xfb, 0x4c, 0x99, 0xeb,
        0x92, 0xa2, 0x74, 0xd2, 0x44, 0xd6, 0x04, 0x92,
        0xc0, 0xe2, 0xe6, 0xe2, 0x12, 0xce, 0xf0, 0xf9,
        0xe3, 0xf6, 0x2e, 0xfd, 0x09, 0x55, 0xe7, 0x1c,
        0x76, 0x8a, 0xa6, 0xbb, 0x3c, 0xd8, 0x0b, 0xbb,
        0x37, 0x55, 0xc8, 0xb7, 0xeb, 0xee, 0x32, 0x71,
        0x2f, 0x40, 0xf2, 0x24, 0x51, 0x19, 0x48, 0x70,
        0x21, 0xb4, 0xb8, 0x4e, 0x15, 0x65, 0xe3, 0xca,
        0x31, 0x96, 0x7a, 0xc8, 0x60, 0x4d, 0x40, 0x32,
        0x17, 0x0d, 0xec, 0x28, 0x0a, 0xee, 0xfa, 0x09,
        0x5d, 0x08, 0xb3, 0xb7, 0x24, 0x1e, 0xf6, 0x64,
        0x6a, 0x6c, 0x86, 0xe5, 0xc6, 0x2c, 0xe0, 0x8b,
        0xe0, 0x99,
    };
    // zig fmt: on

    var bs = bytes.Bytes{ .buf = &in };
    const got = try Initial.decode(std.testing.allocator, &bs);
    defer got.deinit();

    try std.testing.expectEqual(@as(u32, quic_v1), got.version);
    try std.testing.expectEqualSlices(
        u8,
        &[_]u8{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07 },
        got.destination_connection_id.items,
    );
    try std.testing.expectEqualSlices(
        u8,
        &[_]u8{ 0x63, 0x5f, 0x63, 0x69, 0x64 },
        got.source_connection_id.items,
    );
    try std.testing.expectEqual(@as(usize, 0), got.token.items.len);
    try std.testing.expectEqual(@as(u32, 0), got.packet_number);
    // Contains a CRYPTO frame only
    try std.testing.expectEqual(@as(usize, 1), got.payload.items.len);
}

test "decode Client Initial from cloudflare/quiche" {
    // Input data comes from capturing the actual UDP datagram sent from cloudflare/quiche.
    // zig fmt: off
    var in = [_]u8{
        0xc1, 0x00, 0x00, 0x00, 0x01, 0x10, 0x2b, 0x14,
        0x17, 0x22, 0x6e, 0xb8, 0x38, 0x81, 0x7c, 0x2d,
        0xae, 0xb1, 0x71, 0x26, 0x7f, 0xd6, 0x14, 0x99,
        0x68, 0x13, 0x05, 0x52, 0x7e, 0x30, 0x92, 0xa4,
        0x24, 0x60, 0xf4, 0x94, 0x67, 0x82, 0x23, 0xc2,
        0x08, 0x6f, 0x4f, 0x00, 0x41, 0x13, 0x07, 0xc0,
        0x78, 0xeb, 0xf4, 0xf6, 0xd6, 0x4c, 0xcc, 0x42,
        0xf1, 0x9c, 0x03, 0x0c, 0xd5, 0x7e, 0x88, 0x04,
        0x6c, 0x2f, 0xec, 0xd5, 0xc3, 0xbc, 0x74, 0x07,
        0xf2, 0x1a, 0xb1, 0x14, 0xa1, 0x6e, 0x8a, 0x69,
        0x6f, 0x5d, 0xf1, 0xa4, 0xdb, 0x37, 0x87, 0xd0,
        0x27, 0x91, 0x1f, 0x5b, 0x4d, 0x49, 0xfe, 0xb1,
        0x77, 0xff, 0x15, 0x3f, 0x8c, 0xbe, 0x65, 0x65,
        0x9d, 0x1f, 0x83, 0x85, 0xf3, 0x75, 0xf6, 0x0c,
        0x8b, 0x5a, 0xba, 0xa2, 0x8e, 0x65, 0x63, 0xe1,
        0x47, 0x5a, 0x8f, 0x84, 0x5b, 0xfa, 0x1b, 0xac,
        0xac, 0xa5, 0xca, 0xb2, 0x82, 0xc2, 0x1c, 0xd1,
        0x4d, 0xf5, 0x04, 0x41, 0x47, 0x9c, 0xc5, 0xb0,
        0x77, 0xe6, 0x93, 0x60, 0xb1, 0xe1, 0x48, 0x1d,
        0x5d, 0x6f, 0x41, 0x65, 0x35, 0xd8, 0xc4, 0xcc,
        0x17, 0x64, 0x14, 0xfa, 0x1c, 0x2f, 0xe5, 0x90,
        0x8f, 0x2c, 0x30, 0xcf, 0xa4, 0x9e, 0xec, 0x55,
        0xc5, 0xd5, 0x31, 0x7f, 0xc1, 0xe3, 0x62, 0x7f,
        0x62, 0x76, 0xa1, 0xdd, 0x77, 0x47, 0x8c, 0x77,
        0x26, 0x1a, 0x24, 0xfd, 0x7f, 0x5b, 0xf9, 0x3c,
        0x4f, 0x80, 0xa4, 0x22, 0xb8, 0xcd, 0x0a, 0x79,
        0x5d, 0x4a, 0xcd, 0x46, 0xb3, 0xb1, 0xbe, 0xce,
        0xb2, 0x09, 0xae, 0x98, 0x5f, 0xdb, 0x1a, 0xc6,
        0x7f, 0x2c, 0x32, 0xe4, 0xb6, 0xf8, 0x04, 0x85,
        0x74, 0x82, 0x5a, 0x9a, 0xa8, 0xff, 0x2b, 0x53,
        0x57, 0x17, 0x08, 0x19, 0x83, 0x81, 0xda, 0xb7,
        0x86, 0xc8, 0x0f, 0xa8, 0xf7, 0x7c, 0x47, 0xef,
        0xc2, 0x2d, 0x4d, 0x34, 0x4d, 0x68, 0x66, 0xf9,
        0x59, 0x75, 0x61, 0xde, 0x26, 0xca, 0x36, 0x22,
        0xe4, 0x89, 0xc5, 0x0f, 0xa7, 0xe5, 0x1a, 0x0f,
        0xb2, 0x9d, 0xc8, 0xa3, 0x3d, 0xd8, 0x44, 0x9d,
        0x6a, 0xbe, 0xdf, 0xc5, 0x77, 0xf0, 0x8b, 0x12,
        0xa6, 0x84, 0xe0, 0x3a, 0xec, 0x81, 0x37, 0x3f,
        0x6f, 0xf8, 0x15, 0x89, 0x03, 0xbf, 0x8f, 0x3a,
        0x64, 0xe7, 0x4a, 0x0f, 0xbb, 0x01, 0x49, 0xfd,
        0xd4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    };
    // zig fmt: on

    var bs = bytes.Bytes{ .buf = &in };
    const got = try Initial.decode(std.testing.allocator, &bs);
    defer got.deinit();

    try std.testing.expectEqual(@as(u32, quic_v1), got.version);
    try std.testing.expectEqualSlices(
        u8,
        &[_]u8{
            0x2b, 0x14, 0x17, 0x22, 0x6e, 0xb8, 0x38, 0x81,
            0x7c, 0x2d, 0xae, 0xb1, 0x71, 0x26, 0x7f, 0xd6,
        },
        got.destination_connection_id.items,
    );
    try std.testing.expectEqualSlices(
        u8,
        &[_]u8{
            0x99, 0x68, 0x13, 0x05, 0x52, 0x7e, 0x30, 0x92,
            0xa4, 0x24, 0x60, 0xf4, 0x94, 0x67, 0x82, 0x23,
            0xc2, 0x08, 0x6f, 0x4f,
        },
        got.source_connection_id.items,
    );
    try std.testing.expectEqual(@as(usize, 0), got.token.items.len);
    try std.testing.expectEqual(@as(u32, 0), got.packet_number);
    // Contains a CRYPTO frame only
    try std.testing.expectEqual(@as(usize, 1), got.payload.items.len);
}

test "decode Client Initial from aws/s2n-quic" {
    // Input data comes from capturing the actual UDP datagram sent from aws/s2n-quic.
    // zig fmt: off
    var in = [_]u8{
        0xcc, 0x00, 0x00, 0x00, 0x01, 0x08, 0x1f, 0xc6,
        0xe2, 0x5b, 0x1f, 0x44, 0x35, 0x10, 0x10, 0x65,
        0x89, 0xe0, 0x75, 0x0f, 0xa5, 0xc3, 0xb1, 0xae,
        0xbe, 0x0d, 0x7b, 0xa3, 0xc3, 0x49, 0x39, 0x00,
        0x44, 0x8e, 0x14, 0xe8, 0xae, 0x59, 0x5f, 0x1a,
        0xaf, 0xdb, 0x8e, 0x72, 0xdf, 0x37, 0x60, 0x71,
        0x46, 0xb5, 0xb1, 0x90, 0x92, 0x99, 0x88, 0x24,
        0x7a, 0x04, 0x12, 0xf5, 0x1c, 0x3a, 0xc5, 0x05,
        0xfb, 0xab, 0x8e, 0xd0, 0x91, 0x80, 0xdb, 0xfa,
        0xaa, 0xf9, 0x7b, 0xf6, 0x8a, 0x35, 0x56, 0xa8,
        0xf5, 0x46, 0x2c, 0x03, 0x81, 0x32, 0x05, 0xb6,
        0x0a, 0xcd, 0x4d, 0xc1, 0xc3, 0xd5, 0x7c, 0x37,
        0x2c, 0x2f, 0xf8, 0xe8, 0x59, 0x2b, 0xe4, 0x10,
        0x0d, 0xf4, 0x47, 0xfa, 0x09, 0x6a, 0x00, 0x49,
        0x01, 0x35, 0xf9, 0xb3, 0xa9, 0x4e, 0xf2, 0x05,
        0xcb, 0xf5, 0xdf, 0x47, 0x2a, 0xd2, 0xe6, 0xc0,
        0xcf, 0xb1, 0xdd, 0xe0, 0x57, 0x29, 0xd4, 0x68,
        0xbf, 0x67, 0xbe, 0x39, 0x37, 0x8f, 0x61, 0x7d,
        0x4d, 0x73, 0xbc, 0x2c, 0x0e, 0x68, 0x39, 0x1a,
        0x9b, 0xaa, 0x7b, 0xae, 0x24, 0x56, 0x28, 0x34,
        0x64, 0x6b, 0xe0, 0xb5, 0x89, 0x9c, 0x93, 0x13,
        0x29, 0xc1, 0x8a, 0x04, 0x41, 0x63, 0xd3, 0x5f,
        0x62, 0x03, 0x55, 0x03, 0xe1, 0x5e, 0xf0, 0xac,
        0x52, 0x77, 0x62, 0xdb, 0x78, 0x5e, 0x11, 0x42,
        0x91, 0xde, 0x50, 0x2c, 0x5f, 0xad, 0x74, 0x9b,
        0x57, 0x6b, 0x98, 0x54, 0xf0, 0xfd, 0xb1, 0xae,
        0x7f, 0xb1, 0x8d, 0xa8, 0x42, 0x5d, 0x29, 0x49,
        0x06, 0xf8, 0x76, 0xd9, 0xae, 0xac, 0x92, 0x49,
        0xc7, 0x35, 0xf4, 0xda, 0x87, 0xa1, 0x6e, 0x37,
        0xfb, 0x2b, 0x91, 0x11, 0x00, 0xbc, 0xa0, 0x6a,
        0x74, 0xb5, 0xb4, 0x77, 0x03, 0xc6, 0x90, 0xf8,
        0x53, 0x57, 0xe5, 0x62, 0x1c, 0xef, 0xaf, 0x64,
        0x34, 0xdd, 0x11, 0x77, 0x5e, 0xdd, 0x9d, 0x79,
        0xe0, 0x29, 0x27, 0x2c, 0x51, 0x2d, 0x64, 0x1d,
        0xf9, 0xad, 0xd7, 0xc8, 0xf2, 0xdf, 0x0a, 0x6a,
        0x6f, 0xd3, 0xc5, 0xe9, 0x1e, 0x39, 0xee, 0x4b,
        0x26, 0xa0, 0x0d, 0x39, 0x2e, 0x44, 0xd9, 0x3c,
        0xad, 0x52, 0xfb, 0x73, 0x4a, 0x9c, 0xe8, 0xce,
        0x01, 0xd2, 0xf8, 0x94, 0x76, 0xf4, 0x5d, 0x2a,
        0x1c, 0x3b, 0xbb, 0xc7, 0xa2, 0x54, 0x64, 0xed,
        0xd8, 0x14, 0xa8, 0xea, 0x6d, 0x37, 0xd5, 0x97,
        0x57, 0x00, 0xa5, 0xd2, 0xc7, 0x20, 0xa6, 0xd1,
        0x63, 0xb7, 0xbf, 0x19, 0x6c, 0xfb, 0xd1, 0x16,
        0xca, 0xa6, 0x65, 0x8c, 0xdc, 0x54, 0x3a, 0x27,
        0x20, 0x35, 0xf9, 0x53, 0x12, 0xf5, 0xc6, 0x1c,
        0xf6, 0xdb, 0x8a, 0x2c, 0x42, 0x19, 0x2e, 0xda,
        0xf6, 0x62, 0x03, 0xb6, 0xcc, 0xdf, 0x64, 0xbc,
        0x23, 0x17, 0x6a, 0x60, 0x61, 0x94, 0xdd, 0x92,
        0x4b, 0xc3, 0xe5, 0xad, 0x0e, 0x3c, 0x06, 0x2d,
        0x8e, 0x8d, 0x6e, 0xc2, 0xef, 0x71, 0x6f, 0x41,
        0x70, 0xd8, 0x8e, 0x71, 0x34, 0x64, 0x3c, 0xee,
        0x28, 0x7e, 0x28, 0x46, 0x08, 0xa8, 0x3a, 0xbe,
        0x64, 0x47, 0x4c, 0xad, 0x8d, 0x08, 0xe2, 0xea,
        0x58, 0x41, 0x9b, 0xba, 0x44, 0x01, 0x2c, 0xec,
        0xcc, 0xc1, 0x51, 0x0d, 0xb6, 0x36, 0x5d, 0x19,
        0xc7, 0x51, 0x93, 0x73, 0xa7, 0xdf, 0xf5, 0x9a,
        0x79, 0x03, 0x07, 0x27, 0xe0, 0x92, 0x33, 0xdb,
        0x92, 0x73, 0x43, 0xd5, 0x85, 0x0c, 0x3b, 0x8b,
        0x88, 0x74, 0x5b, 0xd8, 0xa2, 0xe4, 0x20, 0x5d,
        0xe0, 0xcb, 0x60, 0x4f, 0x7e, 0xc7, 0x72, 0xb1,
        0x9e, 0x5a, 0x0c, 0x2e, 0xed, 0x03, 0xf3, 0xf6,
        0x82, 0x4b, 0x7b, 0xfe, 0xcf, 0xb8, 0x86, 0xc2,
        0x53, 0xdf, 0x58, 0xe0, 0xa1, 0xba, 0x32, 0x8a,
        0x64, 0x5b, 0x0c, 0xbf, 0x68, 0x5b, 0xa0, 0xca,
        0x06, 0xb6, 0x0f, 0x92, 0x55, 0x9d, 0x1e, 0x7a,
        0xed, 0x88, 0x74, 0xba, 0xa0, 0x20, 0xae, 0x6c,
        0x8b, 0x63, 0xa0, 0x5e, 0x3d, 0x74, 0x1c, 0x37,
        0x86, 0xe0, 0x93, 0x14, 0xcf, 0x68, 0xce, 0x94,
        0x4a, 0x6e, 0xbd, 0x2c, 0xc9, 0x2c, 0xb7, 0x12,
        0xcd, 0xbc, 0x6f, 0x21, 0x61, 0x78, 0x57, 0xe6,
        0x87, 0xb1, 0x73, 0x3c, 0x7b, 0x60, 0xf0, 0x8f,
        0xd8, 0x37, 0x61, 0xb8, 0x5a, 0xca, 0xe0, 0x18,
        0x45, 0xe1, 0x30, 0xd8, 0x9d, 0x6a, 0x9e, 0xc6,
        0x8b, 0x8b, 0xb7, 0x6b, 0xd1, 0x6e, 0x10, 0xdf,
        0x61, 0xad, 0x73, 0x02, 0x7a, 0xf5, 0x00, 0x36,
        0xab, 0x74, 0xf5, 0xe6, 0xb9, 0xa8, 0x58, 0x04,
        0xbc, 0x46, 0x54, 0xdf, 0x6c, 0xbb, 0x5b, 0x2a,
        0xea, 0x75, 0x60, 0xcc, 0x82, 0x39, 0xb2, 0x88,
        0x8e, 0x5c, 0x65, 0x93, 0x80, 0x8e, 0xf0, 0x71,
        0xf8, 0x86, 0x78, 0xae, 0x71, 0x22, 0x71, 0x67,
        0xb0, 0x5a, 0x63, 0x8f, 0xf5, 0x6e, 0x3e, 0x3f,
        0x7a, 0xe4, 0xcd, 0xd4, 0x56, 0xd8, 0xad, 0x85,
        0xaa, 0x2e, 0x49, 0x57, 0x21, 0x44, 0x7e, 0xab,
        0xf7, 0xb2, 0xe1, 0x0c, 0xe4, 0xcc, 0x19, 0x84,
        0xe7, 0x03, 0xe0, 0xab, 0x71, 0x96, 0xf2, 0x54,
        0x4e, 0x86, 0x55, 0x83, 0xfc, 0x85, 0x43, 0x14,
        0x2d, 0x59, 0x41, 0x8d, 0x8b, 0x6e, 0x1d, 0xc6,
        0x0c, 0x1c, 0xef, 0xeb, 0x97, 0x32, 0xe5, 0xf0,
        0x2c, 0x8e, 0xf8, 0x2f, 0xe5, 0x5a, 0xb2, 0x7a,
        0xe5, 0x6b, 0x90, 0x0c, 0xd2, 0x3c, 0x67, 0x09,
        0x7b, 0x28, 0x83, 0x54, 0x59, 0x38, 0xd6, 0x8c,
        0xe2, 0x20, 0xc5, 0x11, 0x25, 0xda, 0x70, 0x11,
        0x78, 0xb1, 0x1f, 0xf3, 0x45, 0xc6, 0x43, 0x5d,
        0x53, 0xdb, 0x96, 0xe0, 0xff, 0x91, 0xb9, 0xd9,
        0x01, 0x57, 0xec, 0xeb, 0xd0, 0x97, 0x48, 0x92,
        0xbf, 0x6b, 0x26, 0xb8, 0xc3, 0x58, 0x87, 0xde,
        0x20, 0xa5, 0x8c, 0xc4, 0x7b, 0x8d, 0xdd, 0x74,
        0x1a, 0x7a, 0xfc, 0xe2, 0x73, 0x90, 0x1c, 0xa4,
        0x60, 0x21, 0x5d, 0x33, 0x6d, 0x62, 0xfd, 0x39,
        0xe5, 0x9b, 0x76, 0x50, 0x96, 0xdf, 0x13, 0xe4,
        0xf4, 0xb5, 0x4e, 0x09, 0xda, 0x29, 0x0d, 0x93,
        0x0f, 0x54, 0x6b, 0xc5, 0x42, 0xf2, 0x91, 0xfe,
        0x7c, 0xa8, 0xd1, 0x00, 0x88, 0x53, 0x13, 0xf9,
        0xd7, 0xe4, 0xd6, 0xd2, 0x21, 0x71, 0xbf, 0x15,
        0xc1, 0x1d, 0xd6, 0x4e, 0xb0, 0x6d, 0x95, 0x78,
        0x9a, 0x89, 0xd5, 0x57, 0x04, 0x63, 0xb5, 0x45,
        0x15, 0x13, 0x5d, 0x76, 0x95, 0xa5, 0x58, 0x26,
        0x0b, 0x7a, 0x49, 0x53, 0xed, 0x00, 0x6a, 0x68,
        0x1d, 0x69, 0x9c, 0x56, 0x83, 0xd3, 0x02, 0x10,
        0x51, 0xfe, 0xb5, 0xe6, 0xc2, 0xae, 0x25, 0x77,
        0xfa, 0x97, 0x12, 0xde, 0x15, 0x39, 0x79, 0x9e,
        0x06, 0x50, 0x77, 0x27, 0x49, 0x71, 0x44, 0xef,
        0x79, 0xa4, 0xae, 0xc8, 0x32, 0xbb, 0x0e, 0xd4,
        0x22, 0x54, 0xdf, 0xbf, 0x96, 0x9d, 0xdc, 0xa0,
        0x71, 0xa7, 0x76, 0x46, 0xc9, 0x0d, 0x2f, 0x4c,
        0x5c, 0xc8, 0x01, 0xf9, 0x84, 0x5a, 0x7a, 0xca,
        0x08, 0x8e, 0xf7, 0x1a, 0x77, 0x2f, 0x2f, 0x5c,
        0x03, 0xad, 0xf9, 0xfa, 0x5b, 0x7d, 0xda, 0x2e,
        0xd2, 0xdb, 0x03, 0xba, 0xf3, 0x04, 0x6d, 0x91,
        0xcf, 0xa0, 0xa3, 0x7e, 0x9f, 0x7f, 0x68, 0x2c,
        0x8f, 0x34, 0x89, 0x09, 0xf9, 0x31, 0x16, 0x55,
        0x2e, 0xde, 0xb7, 0xea, 0x14, 0x62, 0x0c, 0x8f,
        0xd7, 0x53, 0x96, 0x64, 0xd9, 0x3e, 0xeb, 0xdb,
        0xc5, 0xf9, 0x5e, 0xda, 0xc5, 0xa1, 0x21, 0x8c,
        0xc3, 0x13, 0xd3, 0x14, 0x38, 0x24, 0x2d, 0x9f,
        0x1b, 0xf6, 0x78, 0xdc, 0x11, 0xa0, 0x66, 0x77,
        0xd9, 0x36, 0xab, 0xbf, 0xb0, 0x87, 0x6d, 0x40,
        0x5c, 0xe4, 0xc5, 0xc3, 0xe1, 0xe0, 0x5e, 0xa3,
        0xdd, 0x69, 0x7a, 0x4e, 0x64, 0xc5, 0x4a, 0xca,
        0xeb, 0x69, 0x28, 0x4b, 0x1e, 0x44, 0xc1, 0xc3,
        0x6e, 0x6a, 0xea, 0xcb, 0xee, 0x2a, 0xc9, 0x37,
        0xc5, 0xb1, 0xda, 0x3c, 0xe0, 0x87, 0xa5, 0xf4,
        0x05, 0x0b, 0x89, 0xdf, 0x7f, 0x45, 0x37, 0x6f,
        0x0c, 0x5b, 0x54, 0x1b, 0xc4, 0xa3, 0x5e, 0xa1,
        0x34, 0x48, 0x84, 0x40, 0x54, 0x42, 0xdf, 0xbf,
        0x96, 0xb8, 0x4f, 0x8a, 0x35, 0x12, 0x4c, 0x88,
        0xa9, 0x67, 0x69, 0xd0, 0xd4, 0x67, 0xcf, 0x87,
        0x42, 0x6a, 0x14, 0x06, 0x37, 0xac, 0x25, 0xba,
        0x70, 0x72, 0x57, 0x60, 0x46, 0x8d, 0xce, 0xc9,
        0x37, 0x6e, 0x1f, 0xf5, 0xf6, 0xbb, 0xec, 0x8c,
        0xe4, 0xf5, 0x31, 0x04, 0xa5, 0x07, 0xac, 0x36,
        0xd0, 0x9d, 0x27, 0xa0, 0xc8, 0x63, 0x3b, 0x3e,
        0x52, 0x7b, 0x9a, 0x78, 0x2f, 0xb4, 0x69, 0x1e,
        0x2b, 0xa6, 0x7b, 0x83, 0x1e, 0x5b, 0xf8, 0xa8,
        0x45, 0x2c, 0x4b, 0xe4, 0x0f, 0xdf, 0x2b, 0xdf,
        0xe8, 0xb2, 0x3d, 0x11, 0xca, 0x28, 0x0e, 0x30,
        0xa7, 0xdc, 0x5b, 0xda, 0x93, 0xdb, 0x52, 0xa5,
        0x1a, 0x07, 0x12, 0xd4, 0x8d, 0x85, 0xc9, 0x21,
        0x4a, 0x07, 0x19, 0x10, 0x46, 0x93, 0x26, 0x8d,
        0x5b, 0x8c, 0x9c, 0xfb, 0x11, 0x8a, 0x56, 0x6f,
    };
    // zig fmt: on

    var bs = bytes.Bytes{ .buf = &in };
    const got = try Initial.decode(std.testing.allocator, &bs);
    defer got.deinit();

    try std.testing.expectEqual(@as(u32, quic_v1), got.version);
    try std.testing.expectEqualSlices(
        u8,
        &[_]u8{
            0x1f, 0xc6, 0xe2, 0x5b, 0x1f, 0x44, 0x35, 0x10,
        },
        got.destination_connection_id.items,
    );
    try std.testing.expectEqualSlices(
        u8,
        &[_]u8{
            0x65, 0x89, 0xe0, 0x75, 0x0f, 0xa5, 0xc3, 0xb1,
            0xae, 0xbe, 0x0d, 0x7b, 0xa3, 0xc3, 0x49, 0x39,
        },
        got.source_connection_id.items,
    );
    try std.testing.expectEqual(@as(usize, 0), got.token.items.len);
    try std.testing.expectEqual(@as(u32, 0), got.packet_number);
    // Contains 1 CRYPTO frame and 917 PADDING frames
    try std.testing.expectEqual(@as(usize, 918), got.payload.items.len);
}
